{"version":3,"file":"AnyTouch.umd.min.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/any-event/src/main.ts","../src/const.ts","../src/vector.ts","../src/input/adapters/Abstract.ts","../src/input/adapters/Touch.ts","../src/input/adapters/Mouse.ts","../src/input/index.ts","../src/compute/intervalCompute.ts","../src/compute/computeMaxLength.ts","../src/compute/computeVector.ts","../src/compute/computeMulti.ts","../src/compute/computeScale.ts","../src/compute/computeAngle.ts","../src/InputManage.ts","../src/compute/index.ts","../src/compute/computeDistance.ts","../src/compute/computeDeltaXY.ts","../src/Store.ts","../src/const/recognizerStatus.ts","../src/recognitions/Base.ts","../src/recognitions/Tap.ts","../src/recognitions/Press.ts","../src/recognitions/Pan.ts","../src/utils/getHV.ts","../src/recognitions/Swipe.ts","../src/recognitions/Pinch.ts","../src/recognitions/Rotate.ts","../src/AnyTouch.ts","../src/utils/computeTouchAction.ts","../src/vueDirective/index.ts","../src/vueDirective/InstanceManage.ts","../src/main.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","type Listener = ((...payload: any) => void) & { isOnce?: boolean }\n\ninterface ListenersMap {\n    [propName: string]: Listener[];\n}\nexport default class AnyEvent {\n    private _listenersMap: ListenersMap;\n\n    constructor() {\n        this._listenersMap = {};\n    };\n\n    /**\n     * 绑定事件\n     * @param {String|Symbol} 事件名\n     * @param {Function} 回调函数\n     */\n    on(eventName: string, listener: Listener): AnyEvent {\n        if (undefined === this._listenersMap[eventName]) {\n            this._listenersMap[eventName] = [];\n        }\n        this._listenersMap[eventName].push(listener);\n        return this;\n    };\n\n    /**\n     * 添加单次监听器 listener 到名为 eventName 的事件。 \n     * 当 eventName 事件下次触发时，监听器会先被移除，然后再调用。\n     * @param {String|Symbol} 事件名\n     * @param {Function} 回调函数\n     */\n    once(eventName: string, listener: Listener): AnyEvent {\n        listener.isOnce = true;\n        this.on(eventName, listener);\n        return this;\n    };\n\n    /**\n     * 解除绑定 \n     * 如果不指定listener, 那么解除所有eventName对应回调\n     * @param {String|Symbol} 事件名\n     * @param {Function} 回调函数\n     */\n    off(eventName: string, listener?: Listener): AnyEvent {\n        const listeners = this._listenersMap[eventName];\n        // 事件存在\n        if (undefined !== listeners) {\n            // 清空事件名对应的所有回调\n            if (undefined === listener) {\n                delete this._listenersMap[eventName];\n            }\n            // 清空指定回调\n            else {\n                const index = listeners.findIndex((fn: Listener) => fn === listener);\n                listeners.splice(index, 1);\n            }\n        }\n        return this;\n    };\n\n\n\n    /**\n     * 按照监听器注册的顺序，同步地调用每个注册到名为 eventName 的事件的监听器，并传入提供的参数。\n     * @param {String|Symbol} 事件名 \n     * @param {Any} 载荷数据 \n     * @returns {Boolean} 如果事件有监听器，则返回 true，否则返回 false。\n     */\n    emit(eventName: string, ...payload: any): boolean {\n        const listeners = this._listenersMap[eventName];\n        if (undefined !== listeners && 0 < listeners.length) {\n            for (let [index, listener] of listeners.entries()) {\n                if (listener.isOnce) {\n                    let listenerClone = listener;\n                    listeners.splice(index, 1);\n                    listenerClone(...payload);\n                } else {\n                    listener(...payload);\n                }\n            }\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * 检查是否已绑定事件\n     * @param {String|Symbol} 事件名\n     * @returns {Boolean} 是否已绑定\n     */\n    has(eventName: string): boolean {\n        return undefined !== this._listenersMap[eventName] && 0 < this._listenersMap[eventName].length;\n    };\n\n    /**\n     * 返回所有事件名称\n     */\n    getEventNames() {\n        const eventNames: string[] = [];\n        for (let eventName in this._listenersMap) {\n            eventNames.push(eventName);\n        }\n        return eventNames;\n    };\n\n    /**\n     * getEventNames别名, 为了和node的api一致\n     */\n    eventNames() {\n        return this.getEventNames();\n    }\n\n    /**\n     * 销毁实例\n     */\n    destroy() {\n        this._listenersMap = {};\n    };\n};","// 简单判断是否手机设备\n// export const MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n// 是否手机设备\n// export const IS_MOBILE = navigator.userAgent ? MOBILE_REGEX.test(navigator.userAgent) : true;\n\n// 是否支持touch事件\n\nexport const IS_WX = undefined === (<any>window);\nexport const SUPPORT_TOUCH = IS_WX || ('ontouchstart' in window);\n\n// 是否是移动设备\n// export const SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && IS_MOBILE;\n\n// 方向\nexport const DIRECTION_NONE = 1; // 0000 0001\nexport const DIRECTION_LEFT = 2; //  0000 0010\nexport const DIRECTION_RIGHT = 4; // 0000 0100 \nexport const DIRECTION_UP = 8; // 0000 1000\nexport const DIRECTION_DOWN = 16; // 0001 0000\n\n// 位运算 求值 对上上面的4个方向可以简单理解为\"+\"\nexport const DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT; // 6\nexport const DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN; // 24\nexport const DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL; // 30\n\n// 计算触发时间间隔, 防止事件触发就一直计算\nexport const COMPUTE_INTERVAL = 16;\n\n\n// 计算时候取touchs.clientX | clientY\nexport const CLIENT_X = 'clientX';\nexport const CLIENT_Y = 'clientY';\n\n\n// 识别器状态码\nexport const RECOGNIZER_STATUS_POSSIBLE = 1;\nexport const RECOGNIZER_STATUS_BEGAN = 2;\nexport const RECOGNIZER_STATUS_CHANGED = 4;\nexport const RECOGNIZER_STATUS_ENDED = 8;\nexport const RECOGNIZER_STATUS_RECOGNIZED = RECOGNIZER_STATUS_ENDED;\nexport const RECOGNIZER_STATUS_CANCELLED = 16;\nexport const RECOGNIZER_STATUS_FAILED = 32;\n\n// input的类型\nexport const INPUT_START = 'start';\nexport const INPUT_MOVE = 'move';\nexport const INPUT_CANCEL = 'cancel';\nexport const INPUT_END = 'end';\n\n\nexport const NONE = 'none';","import { CLIENT_X, CLIENT_Y } from './const';\nimport { directionString, Point,Vector } from './interface';\n\n/**\n * 获取向量长度(向量模)\n * @param {Object} 向 量\n */\nexport const getVLength = (v: Vector): number => {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n}\n\n/**\n * 点积\n * @param {Object} v1\n * @param {Object} v2\n */\nexport const getDotProduct = (v1: Vector, v2: Vector) => {\n    return v1.x * v2.x + v1.y * v2.y;\n}\n\n/**\n * 向量夹角(弧度)\n * @param {Object} v1\n * @param {Object} v2\n */\nexport const getRadian = (v1: Vector, v2: Vector) => {\n    var mr = getVLength(v1) * getVLength(v2);\n    if (mr === 0) return 0;\n    var r = getDotProduct(v1, v2) / mr;\n    if (r > 1) r = 1;\n    return Math.acos(r);\n}\n\n/**\n * 求旋转方向\n * 顺时针/逆时针\n */\nexport const getCross = (v1: Vector, v2: Vector) => {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\n/**\n * 向量夹角(角度)\n * @param {Object} v1\n * @param {Object} v2\n */\nexport const getAngle = (v1: Vector, v2: Vector) => {\n    var angle = getRadian(v1, v2);\n    if (getCross(v1, v2) > 0) {\n        angle *= -1;\n    }\n    return radianToAngle(angle);\n};\n\n/**\n * 弧度转角度\n * @param {Number} 弧度 \n */\nexport const radianToAngle = (radian: number): number => radian / Math.PI * 180;\n\n/**\n * 角度转弧度\n * @param {Number} 角度 \n */\nexport const angleToRadian = (angle: number): number => angle / 180 * Math.PI;\n\n/**\n * 获取多点之间的中心坐标\n * @param {Array} 触碰点 s\n */\nexport const getCenter = (points: { clientX: number, clientY: number }[]): Point => {\n    const { length } = points;\n    // 由于是触碰后才运行getCenter, 所以一定至少有一个点(end阶段也有clientX/Y)\n    // 所以不做 0 < length 的判断了\n    const countPoint = points.reduce((countPoint: Point, point: any) => {\n        countPoint.x += point[CLIENT_X];\n        countPoint.y += point[CLIENT_Y];\n        return countPoint;\n    }, { x: 0, y: 0 });\n    return { x: Math.round(countPoint.x / length), y: Math.round(countPoint.y / length) }\n};\n\n/**\n * \n * @param {Number} 事件开始到结束的X位移 \n* @param {Number} 事件开始到结束的Y位移 \n */\nexport const getDirection = (x: number, y: number): directionString => {\n    if (x === y) {\n        return 'none';\n    } else if (Math.abs(x) > Math.abs(y)) {\n        return 0 < x ? 'right' : 'left';\n    } else {\n        return 0 < y ? 'down' : 'up';\n    }\n};\n","import { BaseInput, SupportEvent } from '../../interface';\n// 适配器的抽象类\nexport default abstract class {\n    abstract load(event: SupportEvent): BaseInput|void\n}; ","import { BaseInput, eventType } from '../../interface';\nimport Adapter from './Abstract';\nexport default class extends Adapter {\n    load(event: TouchEvent):BaseInput {\n        const points = Array.from(event.touches).map(({ clientX, clientY }) => ({ clientX, clientY }));\n        const changedPoints = Array.from(event.changedTouches).map(({ clientX, clientY }) => ({ clientX, clientY }));\n        return {\n            eventType: <eventType>event.type.replace('touch', ''),\n            changedPoints,\n            points,\n            nativeEvent: event\n        };\n    }\n}; ","import { BaseInput, eventType } from '../../interface';\n// 默认MouseEvent中对type声明仅为string\nimport Adapter from './Abstract';\nexport default class extends Adapter {\n    prevPoints?: { clientX: number, clientY: number }[];\n    isPressed: boolean;\n    constructor() {\n        super();\n        this.isPressed = false;\n    };\n\n    load(event: MouseEvent): BaseInput | void {\n        let { clientX, clientY, type, button } = event;\n\n        // changedPoints = prevPoints其实并不能完全等于touch下的changedPoints\n        // 但是由于鼠标没有多点输入的需求, \n        // 所以暂时如此实现\n        const changedPoints = this.prevPoints || [{ clientX, clientY }];\n\n        let points = [{ clientX, clientY }];\n        this.prevPoints = [{ clientX, clientY }];\n\n        // 必须左键\n        if ('mousedown' === type) {\n            if (0 === button) {\n                this.isPressed = true;\n            } else {\n                return;\n            }\n        }\n\n        if ('mousemove' === type) {\n            if (!this.isPressed) return;\n            // 确保移动过程中, 一直按住的都是左键,\n            // if(1 !== event.which) {\n            //     type = 'mouseup'\n            // }\n        } else if ('mouseup' === type) {\n            if (this.isPressed) {\n                points = [];\n            } else {\n                return;\n            };\n            this.isPressed = false;\n        }\n\n        const MAP = {\n            mousedown: 'start',\n            mousemove: 'move',\n            mouseup: 'end'\n        };\n\n        return {\n            eventType: <eventType>MAP[<'mousedown' | 'mousemove' | 'mouseup'>type],\n            changedPoints,\n            points,\n            nativeEvent: event\n        };\n    }\n}; ","/**\n * 构造统一的Input格式\n */\nimport { Input, Point, SupportEvent } from '../interface';\nimport { SUPPORT_TOUCH, INPUT_END, INPUT_START, INPUT_CANCEL } from '../const';\nimport { getCenter } from '../vector';\nimport Touch from './adapters/Touch';\nimport Mouse from './adapters/Mouse';\nimport Adapter from './adapters/Abstract';\n\nexport default class {\n    // 缓存触点中心\n    private _center?: Point;\n    public adapter: Adapter;\n    constructor() {\n        this.adapter = SUPPORT_TOUCH ? new Touch() : new Mouse();\n    };\n\n    public load(event: SupportEvent): Input | void {\n        // 从event中采集的数据\n        const BASE_INPUT = this.adapter.load(event);\n\n        if (undefined === BASE_INPUT) {\n            return;\n        }\n        const { eventType, points, changedPoints } = BASE_INPUT;\n        // 当前触点数\n        const pointLength = points.length;\n\n        // 变化前触点数\n        const changedPointLength = changedPoints.length;\n\n        // 识别流程的开始和结束标记\n        // 只要触点增加了就是一个识别阶段的\"开始\"\n        const isStart = (INPUT_START === eventType)\n        // 任意触点离开算作\"结束\", 这和hammer.js不一样\n        // 注意这个\"结束\"只能给pan等移动类手势用, tap比较特殊, 不会用到这个属性\n        const isEnd = (INPUT_END === eventType || INPUT_CANCEL === eventType);\n        //  && (0 === pointLength);\n\n        // 中心坐标\n        if (0 < pointLength) {\n            this._center = getCenter(BASE_INPUT.points);\n        }\n\n        // 当前时间\n        const timestamp = Date.now();\n\n        // 原生属性/方法\n        const { target, currentTarget } = event;\n        const { x, y } = <Point>(this._center || {});\n\n        // console.log(`isStart= ${isStart&& '是'}, isEnd= ${isEnd&& '是'}, ${eventType},${pointLength},${changedPointLength} ,x: ${x} ,y: ${y}`);\n\n        return {\n            ...BASE_INPUT,\n            preventDefault: () => {\n                event.preventDefault();\n            },\n            isStart,\n            isEnd,\n            pointLength,\n            changedPointLength,\n            center: this._center,\n            x, y,\n            timestamp,\n            target,\n            currentTarget,\n            nativeEvent: event\n        };\n    };\n}","// 返回最近一个时间段的计算结果\n// 默认间隔25ms做一次计算, 让数据更新,\n// 让end阶段读取上一步的计算数据, 比如方向, 速率等...\n// 防止快速滑动到慢速滑动的手势识别成swipe\nimport { Input,directionString } from '../interface';\nimport { COMPUTE_INTERVAL, INPUT_CANCEL, INPUT_END } from '../const';\nimport { getDirection } from '../vector';\nimport Store from '../Store';\n\nexport default ({ prevInput, input }: { prevInput?: Input, input?: Input },$store:Store): { speedX: number, speedY: number, velocityX: number, velocityY: number, direction?: directionString } => {\n\n    // 速率\n    let velocityX = 0;\n    let velocityY = 0;\n\n    // 速度\n    let speedX = 0;\n    let speedY = 0;\n\n    // 方向\n    let direction: directionString = 'none';\n\n    // 点击鼠标左键, 会出现undefined\n    if (undefined !== input) {\n        // _prevInput || input用来保证deltaX等不会有undefined参与计算\n        const _prevInput = prevInput || input;\n        const deltaTime = input.timestamp - _prevInput.timestamp;\n        // 每16ms刷新速度数据\n        if (-1 === [INPUT_CANCEL, INPUT_END].indexOf(input.eventType) && (COMPUTE_INTERVAL < deltaTime || undefined === $store.get('direction'))) {\n            const deltaX = input.x - _prevInput.x;\n            const deltaY = input.y - _prevInput.y;\n            speedX = Math.round(deltaX / deltaTime * 100) / 100;\n            speedY = Math.round(deltaY / deltaTime * 100) / 100;\n            velocityX = Math.abs(speedX);\n            velocityY = Math.abs(speedY);\n            direction = getDirection(deltaX, deltaY) || <directionString>($store.get('direction'));\n            // 存储状态\n            $store.set({ speedX });\n            $store.set({ speedY });\n            $store.set({ velocityX });\n            $store.set({ velocityY });\n            $store.set({ direction });\n        } else {\n            speedX = $store.get('speedX', 0);\n            speedY = $store.get('speedY', 0);\n            velocityX = $store.get('velocityX', 0);\n            velocityY = $store.get('velocityY', 0);\n            direction = $store.get('direction');\n        }\n    }\n\n    return { velocityX, velocityY, speedX, speedY, direction };\n};","import Store from '../Store';\n\nexport default ({ pointLength, isStart }: { pointLength: number, isStart: boolean }, $store: Store): number => {\n    if (isStart) {\n        const maxLength = $store.get('maxPointLength', 0);\n        if (pointLength > maxLength) {\n            $store.set({ maxPointLength: pointLength });\n        }\n        return pointLength;\n    }\n    return $store.get('maxPointLength', 0)\n};","import { Input } from '../interface';\nimport { CLIENT_X, CLIENT_Y } from '../const';\nexport default (input: Input): { x: number, y: number } => ({\n    x: input.points[1][CLIENT_X] - input.points[0][CLIENT_X],\n    y: input.points[1][CLIENT_Y] - input.points[0][CLIENT_Y]\n});","\nimport { Input } from '../interface';\nimport computeVector from './computeVector';\nimport computeScale from './computeScale';\nimport computeAngle from './computeAngle';\nimport Store from '../Store';\ntype Arg = {\n    startMultiInput?: Input,\n    prevInput?: Input,\n    input: Input\n};\n\ntype Ret = {\n    scale: number;\n    deltaScale: number;\n    angle: number;\n    deltaAngle: number\n}\n\nexport default function ({\n    startMultiInput,\n    prevInput,\n    input\n}: Arg, $store: Store): Ret {\n    // 上一触点数大于1, 当前触点大于1\n    // 连续第二次出现多点, 才能开始计算\n    if (undefined !== prevInput && 1 < prevInput.points.length && 1 < input.points.length) {\n        // 2指形成的向量\n        const startV = computeVector(<Input>startMultiInput);\n        const prevV = computeVector(prevInput);\n        const activeV = computeVector(input);\n        // 计算缩放\n        const { scale, deltaScale } = computeScale({\n            startV, activeV, prevV\n        });\n\n        // ========= 计算旋转角度 =========\n        const { deltaAngle, angle } = computeAngle({ startV, prevV, activeV });\n        $store.set({ angle });\n        $store.set({ scale });\n        return { scale, deltaScale, deltaAngle, angle };\n    } else {\n        return {\n            scale: $store.get('scale', 1),\n            deltaScale: 1,\n            deltaAngle: 0,\n            angle: $store.get('angle', 0)\n        };\n    }\n};","import { Vector } from '../interface';\nimport { getVLength } from '../vector';\nexport default function ({\n    startV, prevV, activeV\n}:  Record<string,Vector>): { scale: number, deltaScale: number } {\n    const deltaScale = getVLength(activeV) / getVLength(prevV);\n    const scale = getVLength(activeV) / getVLength(startV);\n    return { scale, deltaScale };\n};","import { Vector } from '../interface';\nimport { getAngle } from '../vector';\nexport default function ({\n    startV, prevV, activeV\n}: Record<string,Vector>): { angle: number, deltaAngle: number } {\n    const deltaAngle = getAngle(activeV, prevV);\n    const angle = getAngle(activeV, startV);\n    return { angle, deltaAngle };\n};","import { Input, SupportEvent, InputRecord, AnyTouchEvent,Store } from './interface';\nimport InputFactory from './input';\nimport compute from './compute/index';\nexport default class {\n    // 起点(单点|多点)\n    startInput?: Input;\n    // 前一次的触电\n    prevInput?: Input;\n    // 当前触点\n    activeInput?: Input;\n    // 多点触碰的起点\n    startMultiInput?: Input;\n\n    inputFactory: InputFactory;\n\n    $store: Store;\n\n    constructor({ $store }: { $store: Store }) {\n        this.inputFactory = new InputFactory();\n        this.$store = $store;\n    };\n\n    /**\n     * 读取事件对象\n     * @param {SupportEvent} 支持传入的事件对象 \n     * @returns {AnyTouchEvent} AnyTouchEvent\n     */\n    load(event: SupportEvent): AnyTouchEvent | void {\n        // 格式化不同设备输入数据\n        const input = this.inputFactory.load(event);\n        // 过滤无效的输入    \n        if (undefined === input) return;\n        const record = this._record(input);\n        return compute(record, this.$store);\n    };\n\n    /**\n     * 记录计算所需的几个输入\n     * @param {Input} 输入\n     * @return {InputRecord} 输入记录\n     */\n    private _record(input: Input): InputRecord {\n        // 当前输入状态\n        const { eventType } = input;\n        // 获取上一点\n        this.prevInput = this.activeInput;\n\n        if ('start' === eventType) {\n            // 起点(单点|多点)\n            if (input.isStart) {\n                this.startInput = input;\n            }\n\n            // 起点(多点)\n            if (1 < input.pointLength) {\n                this.startMultiInput = input;\n            } else {\n                // 如果出现了单点, 那么之前的多点起点记录失效\n                this.startMultiInput = undefined;\n            }\n        }\n        // 当前点\n        this.activeInput = input;\n\n        return {\n            startMultiInput: this.startMultiInput,\n            startInput: <Input>this.startInput,\n            prevInput: this.prevInput,\n            input\n        };\n    };\n}; ","\nimport { AnyTouchEvent, InputRecord,Store } from '../interface';\nimport intervalCompute from './intervalCompute';\nimport computeDistance from './computeDistance';\nimport computeDeltaXY from './computeDeltaXY';\nimport computeMaxLength from './computeMaxLength';\nimport computMulti from './computeMulti';\n\nexport default function (inputs: InputRecord, $store: Store): AnyTouchEvent {\n    const { input } = inputs;\n    // ========= 整体距离/位移=========\n    const { displacementX, displacementY, distanceX, distanceY, distance, overallDirection } = computeDistance(inputs, $store);\n\n    // ========= 已消耗时间 =========\n    const deltaTime = inputs.input.timestamp - inputs.startInput.timestamp;\n\n    // ========= 最近25ms内计算数据, 瞬时数据 =========\n    const { velocityX, velocityY, speedX, speedY, direction } = intervalCompute(inputs, $store);\n\n    // ========= 中心点位移增量 =========\n    const { deltaX, deltaY, deltaXYAngle } = computeDeltaXY(inputs, $store);\n\n\n    // ========= 多点计算 =========\n    // 上一触点数大于1, 当前触点大于1\n    // 连续第二次出现多点, 才能开始计算\n    const { scale,\n        deltaScale,\n        angle,\n        deltaAngle } = computMulti(inputs, $store);\n\n    const maxPointLength = computeMaxLength(input, $store);\n    return {\n        type: '',\n        ...input,\n        velocityX,\n        velocityY,\n        speedX,\n        speedY,\n        deltaTime,\n        overallDirection,\n        direction,\n        deltaX, deltaY, deltaXYAngle,\n        displacementX,\n        displacementY,\n        distanceX,\n        distanceY,\n        distance,\n        scale,\n        deltaScale,\n        angle,\n        deltaAngle,\n        maxPointLength\n    };\n};","\nimport { Input,directionString } from '../interface';\nimport { CLIENT_X, CLIENT_Y } from '../const';\nimport { getVLength, getDirection } from '../vector';\nimport Store from '../Store';\nexport default function ({\n    startInput,\n    input\n}: {\n    startInput: Input,\n    input: Input\n},$store:Store): { displacementX: number, displacementY: number, distanceX: number, distanceY: number, distance: number, overallDirection: directionString } {\n    const { eventType } = input;\n    let displacementX = 0;\n    let displacementY = 0;\n    if ('start' === eventType) {\n        $store.set({ displacementX });\n        $store.set({ displacementY });\n    } else if ('move' === eventType) {\n        displacementX = Math.round(input!.points[0][CLIENT_X] - startInput!.points[0][CLIENT_X]);\n        displacementY = Math.round(input!.points[0][CLIENT_Y] - startInput!.points[0][CLIENT_Y]);\n        // 记录本次位移\n        $store.set({ displacementX });\n        $store.set({ displacementY });\n    } else if ('end' === eventType) {\n        displacementX = $store.get('displacementX', 0);\n        displacementY = $store.get('displacementY', 0);\n    }\n\n    const distanceX = Math.abs(displacementX);\n    const distanceY = Math.abs(displacementY);\n    const distance = Math.round(getVLength({ x: distanceX, y: distanceY }));\n    const overallDirection = getDirection(displacementX, displacementY);\n    return {\n        displacementX, displacementY, distanceX, distanceY, distance, overallDirection\n    };\n};","import { radianToAngle } from '../vector';\nimport { Store, InputRecord } from '../interface';\nexport default function ({\n    prevInput,\n    input\n}: InputRecord, $store: Store): { deltaX: number, deltaY: number, deltaXYAngle: number } {\n    // 每次事件触发时位移的变化\n    let deltaX: number;\n    let deltaY: number;\n    // deltaX/Y与2者合位移的角度\n    let deltaXYAngle: number = 0;\n\n    // 计算deltaX/Y\n    // if ('end' === input.eventType || 'start' === input.eventType) {\n    if (undefined === prevInput) {\n        deltaX = 0;\n        deltaY = 0;\n    } else {\n        deltaX = input.x - prevInput.x;\n        deltaY = input.y - prevInput.y;\n    }\n\n    // 计算deltaXAngle / deltaYAngle\n    if (0 !== deltaX || 0 !== deltaY) {\n        const deltaXY = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n        deltaXYAngle = Math.round(radianToAngle(Math.acos(Math.abs(deltaX) / deltaXY)));\n        $store.set({ deltaXYAngle });\n    } else {\n        deltaXYAngle = $store.get('deltaXYAngle', 0);\n    }\n\n    return { deltaX, deltaY, deltaXYAngle };\n};","export default class{\n    store: Record<string, any>;\n\n    constructor() {\n        this.store = {};\n    }\n\n    set(object: object) {\n        this.store = { ...this.store, ...object };\n    };\n\n    get<T>(key: string, defaultValue?: T): T {\n        return this.store[key] || defaultValue;\n    };\n\n    reset() {\n        this.store = {};\n    }\n\n    destroy() {\n        this.reset()\n    }\n}\n","// 识别器状态码\n// 注意: 此处的值会直接被事件名所用, 如panstart/panmove等等\nexport const STATUS_POSSIBLE = 'possible';\nexport const STATUS_START = 'start';\nexport const STATUS_MOVE = 'move';\nexport const STATUS_END = 'end';\nexport const STATUS_CANCELLED = 'cancel';\nexport const STATUS_FAILED = 'failed';\nexport const STATUS_RECOGNIZED = 'recognized';","import { AnyTouchEvent, directionString } from '../interface';\nimport { INPUT_CANCEL, INPUT_END, INPUT_MOVE } from '../const';\nimport {\n    STATUS_POSSIBLE,\n    STATUS_START,\n    STATUS_MOVE,\n    STATUS_END,\n    STATUS_CANCELLED,\n    STATUS_FAILED, STATUS_RECOGNIZED\n} from '../const/recognizerStatus';\n\nexport default abstract class Recognizer {\n    // 手势名\n    public name: string;\n    // 是否禁止\n    public disabled: boolean;\n    // 识别状态\n    public status: string;\n    // 是否已识别\n    public isRecognized: boolean;\n    // 选项\n    public options: { [propName: string]: any };\n    // 需要对应手势失败才能识别成功\n    public requireFailureRecognizers: any[];\n    // 存储外部注入方法的容器\n    public $root: any;\n\n    public eventEmitter: any;\n\n    public isWaitingOther: boolean;\n\n    constructor(options: { name?: string, [k: string]: any }) {\n        this.options = { ...(<any>this.constructor).DEFAULT_OPTIONS, disabled: false, ...options };\n        this.name = this.options.name;\n        this.disabled = this.options.disabled;\n        this.status = STATUS_POSSIBLE;\n        this.isRecognized = false;\n        this.requireFailureRecognizers = [];\n        this.isWaitingOther = false;\n        // 这里面不能直接调用$root等, \n        // 因为rollup生成的代码构造函数并不是该constructor\n        // 而是构造函数中又嵌套了一个同名构造函数\n    };\n\n    /**\n     * 设置识别器\n     * @param {Object} 选项 \n     */\n    public set(options = {}) {\n        this.options = { ...this.options, ...options };\n        // 刷新anyTouch\n        this.$root.update();\n        return this;\n    };\n\n    public $injectRoot($root: any) {\n        this.$root = $root;\n        return this;\n    }\n\n    /**\n     * 对eventEmitter进行封装\n     * @param type \n     * @param payload \n     */\n    public emit(type: string, payload: any) {\n        payload.type = type;\n        this.$root.eventEmitter.emit(type, payload);\n\n        if (undefined !== this.$root.el) {\n            if (this.$root.options.syncToAttr) {\n                this.$root.el.setAttribute('at-gesture', type);\n            }\n            if (this.$root.options.hasDomEvents) {\n                // 过滤掉几个Event上保留的字段\n                let { target, currentTarget, type, ...data } = payload;\n                let event = new Event(type, payload);\n                Object.assign(event, data);\n                this.$root.el.dispatchEvent(event);\n            }\n        }\n    };\n\n    /**\n     * 前者需要后者识别失败才能触发\n     * @param {Recognizer} 识别器实例 \n     */\n    public requireFailure(recognizer: this) {\n        if (!this.requireFailureRecognizers.includes(recognizer)) {\n            this.requireFailureRecognizers.push(recognizer);\n        }\n    };\n\n    /**\n     * 移除识别器之间的\"需要失败\"关系\n     *  @param {Recognizer} 识别器实例 \n     */\n    public removeRequireFailure(recognizer: Recognizer) {\n        for (let [index, requireFailureRecognizer] of this.requireFailureRecognizers.entries()) {\n            if (requireFailureRecognizer.name === recognizer.name) {\n                this.requireFailureRecognizers.splice(index, 1);\n                break;\n            }\n        }\n    };\n\n    /**\n     * 是否需要其他手势失败才能触发\n     */\n    public hasRequireFailure() {\n        return 0 < this.requireFailureRecognizers.length;\n    };\n\n    /**\n     * 是否所有\"需要失败\"的手势都是disabled的\n     */\n    public isAllRequireFailureRecognizersDisabled() {\n        return this.requireFailureRecognizers.every((recognizer: any) => recognizer.disabled);\n    };\n\n    /**\n     * 是否要求注册时指定失败的选择器是失败状态\n     */\n    public isAllRequiresFailedOrPossible(): boolean {\n        for (let recognizer of this.requireFailureRecognizers) {\n            // console.log(this.name, this.isWaitingOther)\n            if (recognizer.isWaitingOther) return false;\n            if (STATUS_FAILED !== recognizer.status && STATUS_POSSIBLE !== recognizer.status) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * 验证触点\n     * @param {Number} 触点数\n     */\n    public isValidPointLength(pointLength: number): boolean {\n        return 0 === this.options.pointLength || this.options.pointLength === pointLength;\n    };\n\n    /**\n     * 是否只支持水平方向\n     */\n    public isOnlyHorizontal() {\n        let isOnlyHorizontal = true;\n        for (let direction of this.options.directions) {\n            isOnlyHorizontal = -1 < ['left', 'right'].indexOf(direction);\n            if (!isOnlyHorizontal) {\n                return false;\n            }\n        }\n        return isOnlyHorizontal;\n    };\n\n    /**\n     * 是否只支持垂直方向\n     */\n    public isOnlyVertical() {\n        let isOnlyVertical = true;\n        for (let direction of this.options.directions) {\n            isOnlyVertical = -1 < ['up', 'down'].indexOf(direction);\n            if (!isOnlyVertical) {\n                return false;\n            }\n        }\n        return isOnlyVertical;\n    };\n\n    /**\n     * 是否支持该方向\n     * @param {String} 方向 \n     */\n    public isVaildDirection(direction?: directionString) {\n        return -1 !== this.options.directions.indexOf(direction) || 'none' === direction;\n    };\n\n    public flow(isVaild: boolean, activeStatus: string, touchDevice: string): string {\n        // if(this.name ==='swipe' ) {\n        //     console.log(isVaild, activeStatus, touchDevice);\n        // }\n        const STATE_MAP: { [k: number]: any } = {\n            // isVaild === true,\n            // Number(true) === 1\n            // 这个分支不会出现STATUS_FAILED\n            // STATUS_END在上面的代码中也会被重置为STATUS_POSSIBLE, 从而进行重新识别\n            1: {\n                [STATUS_POSSIBLE]: {\n                    [INPUT_MOVE]: STATUS_START,\n                    [INPUT_END]: STATUS_RECOGNIZED,\n                    [INPUT_CANCEL]: STATUS_CANCELLED\n                },\n                [STATUS_START]: {\n                    [INPUT_MOVE]: STATUS_MOVE,\n                    [INPUT_END]: STATUS_END,\n                    [INPUT_CANCEL]: STATUS_CANCELLED\n                },\n                [STATUS_MOVE]: {\n                    [INPUT_MOVE]: STATUS_MOVE,\n                    [INPUT_END]: STATUS_END,\n                }\n            },\n            // isVaild === false\n            // 这个分支有STATUS_FAILED\n            0: {\n                [STATUS_START]: {\n                    [INPUT_MOVE]: STATUS_CANCELLED,\n                    [INPUT_END]: STATUS_END,\n                    [INPUT_CANCEL]: STATUS_CANCELLED\n                },\n                [STATUS_MOVE]: {\n                    [INPUT_MOVE]: STATUS_CANCELLED,\n                    [INPUT_END]: STATUS_END,\n                    [INPUT_CANCEL]: STATUS_CANCELLED\n                }\n            }\n        };\n        // console.warn(Number(isVaild),activeStatus, STATE_MAP[Number(isVaild)][activeStatus]);\n        if (undefined !== STATE_MAP[Number(isVaild)][activeStatus]) {\n            return STATE_MAP[Number(isVaild)][activeStatus][touchDevice] || activeStatus;\n        } else {\n            return activeStatus;\n        }\n    };\n\n    /**\n     * 如果识别结束, 那么重置状态\n     */\n    protected _resetStatus() {\n        // if (this.name === 'tap') console.log('@', this.status);\n        //STATUS_RECOGNIZED === STATUS_END\n        if (-1 !== [STATUS_END, STATUS_CANCELLED, STATUS_RECOGNIZED, STATUS_FAILED].indexOf(this.status)) {\n\n            this.status = STATUS_POSSIBLE;\n        };\n    };\n\n    /**\n     * 适用于大部分移动类型的手势, \n     * 如pan/rotate/pinch/swipe\n     * @param {AnyTouchEvent} 计算数据 \n     */\n    recognize(computed: AnyTouchEvent) {\n        // if(!computed.isStart) return;\n        // if(this.name === 'pan')    console.log(this.name,this.status);\n        // 是否识别成功\n        let isVaild = this.test(computed);\n\n        // 重置status\n        this._resetStatus();\n\n        // 状态变化流程\n        let { eventType } = computed;\n\n        this.status = this.flow(isVaild, this.status, eventType);\n\n        if (STATUS_CANCELLED === this.status) {\n            this.emit(this.options.name + 'cancel', computed);\n            return;\n        }\n\n        // 是否已识别\n        this.isRecognized = -1 < [STATUS_START, STATUS_MOVE, STATUS_END, STATUS_RECOGNIZED].indexOf(this.status);\n        // 识别后触发的事件\n        if (isVaild) {\n            this.afterRecognized(computed);\n            // computed = this.lockDirection(computed);\n            this.emit(this.options.name, computed);\n\n            // panstart等\n            this.emit(this.options.name + this.status, computed);\n\n            this.afterEmit(computed);\n        } else if (this.isRecognized) {\n            // panmove | panend等\n            this.emit(this.options.name + this.status, computed);\n            \n        }\n    };\n\n    /**\n     * 识别条件, 基于异步\n     * @param {AnyTouchEvent} 计算数据\n     * @param {(isRecognized: boolean) => void}} 接收是否识别状态\n     */\n    abstract test(computed: AnyTouchEvent): boolean;\n\n    /**\n     * 识别成功后执行\n     * 这个阶段可以对computed数据做些处理\n     * 比如pan可以针对不支持的方向吧deltaX/Y调整为0\n     * swipe可以把不支持的方向上的速率调整为0\n     * @param {AnyTouchEvent} 计算数据 \n     */\n    public afterRecognized(computed: AnyTouchEvent): void { };\n\n    /**\n     * 基类的所有emit触发后执行\n     * @param {AnyTouchEvent} computed \n     */\n    public afterEmit(computed: AnyTouchEvent): void { };\n\n    /**\n     * 计算当前手势的touch-action\n     */\n    abstract getTouchAction(): string[];\n};\n\n","import { AnyTouchEvent, Point } from '../interface';\nimport {\n    STATUS_RECOGNIZED, STATUS_POSSIBLE,\n    STATUS_FAILED,\n} from '../const/recognizerStatus';\nimport Recognizer from './Base';\nimport { INPUT_END } from '../const';\nimport { getVLength } from '../vector';\n\nexport default class TapRecognizer extends Recognizer {\n    public tapCount: number;\n\n\n    // 记录每次单击完成时的坐标\n    public prevTapPoint?: Point;\n    public prevTapTime?: number;\n\n    // 多次tap之间的距离是否满足要求\n    public isValidDistanceFromPrevTap?: boolean;\n\n    // timer\n    private _delayFailTimer?: number;\n    private _waitOtherFailedTimer?: number;\n\n    static DEFAULT_OPTIONS = {\n        name: 'tap',\n        pointLength: 1,\n        tapTimes: 1,\n        // 等待下一次tap的时间, \n        // 超过该事件就立即判断当前点击数量\n        waitNextTapTime: 300,\n        disabled: false,\n        // 从接触到离开允许产生的最大距离\n        positionTolerance: 2,\n        // 2次tap之间允许的最大位移\n        tapsPositionTolerance: 9,\n        // 从接触到离开屏幕的最大时间\n        maxPressTime: 250,\n    };\n    constructor(options = {}) {\n        super(options);\n        this.tapCount = 0;\n    };\n\n    public getTouchAction() {\n        // 单击auto, 多击manipulation=pan + pinch-zoom(禁用了默认双击)\n        return (1 < this.options.tapTimes) ? ['manipulation'] : ['auto'];\n    };\n\n    /**\n     * 判断前后2次点击的距离是否超过阈值\n     * @param {Point} 当前触点\n     * @return {Boolean} 前后2次点击的距离是否超过阈值\n     */\n    private _isValidDistanceFromPrevTap(point: Point): boolean {\n        // 判断2次点击的距离\n        if (undefined !== this.prevTapPoint) {\n            const distanceFromPreviousTap = getVLength({ x: point.x - this.prevTapPoint.x, y: point.y - this.prevTapPoint.y });\n            // 缓存当前点, 作为下次点击的上一点\n            this.prevTapPoint = point;\n            return this.options.tapsPositionTolerance >= distanceFromPreviousTap;\n        } else {\n            this.prevTapPoint = point;\n            return true;\n        }\n    };\n\n    /**\n     * 校验2次tap的时间间隔是否满足\n     * @return {Boolean} 是否满足\n     */\n    private _isValidInterval(): boolean {\n        const now = Date.now();\n        if (undefined === this.prevTapTime) {\n            this.prevTapTime = now;\n            return true;\n        } else {\n            const interval = now - this.prevTapTime;\n            this.prevTapTime = now;\n            return interval < this.options.waitNextTapTime;\n        }\n    };\n\n    /**\n     * 识别后执行, 流程如下:  \n     *             开始   \n     *              |\n     *         <是否end阶段> - 否 - 结束\n     *              |\n     *          关闭定时器c1和c2\n     *              |\n     *          清除等待状态\n     *              |\n     *              是\n     *              |\n     *        重置状态为\"可能是\"\n     *              |\n     *        <是否满足单击条件> - 否 - 结束\n     *              |\n     *              是\n     *              |\n     *       <是否正确连击：是否上次点击信息为空 或 与上次点击的位移/时间是否满足约束> - 否 - 点击次数=1 - 继续(<是否到达点击数要求>)\n     *              |\n     *              是\n     *              |\n     *           点击次数+1\n     *              |\n     *       <是否到达点击数要求> - 否 - 设置定时器c1(t1毫秒后状态设置为\"失败\") - 结束\n     *              |\n     *              是\n     *              |\n     *      <是否需要其他手势失败> - 否 - 触发事件, 状态设置为\"已识别\",重置(点击次数,位置) - 结束\n     *              |\n     *              是\n     *              |\n     *           进入等待状态\n     *              |\n     *  <设置定时器c2(t1毫秒后检查\"需要失败\"的手势是否是\"失败\"状态, 重置(点击次数,位置, 等待状态)> - 否 - 设置状态为\"失败\" - 结束\n     *              |\n     *              是\n     *              |\n     *       触发, 状态设置为\"已识别\", 重置(点击次数,位置)\n     *              |\n     *             结束\n     * \n     * @param {AnyTouchEvent} 计算数据 \n     */\n    public recognize(computed: AnyTouchEvent): void {\n        // 只在end阶段去识别\n        if (INPUT_END !== computed.eventType) return;\n\n        this.status = STATUS_POSSIBLE;\n\n        // 每一次点击是否符合要求\n        if (this.test(computed)) {\n            clearTimeout(this._delayFailTimer);\n            clearTimeout(this._waitOtherFailedTimer);\n            this.isWaitingOther = false;\n            // 判断2次点击之间的距离是否过大\n            // 对符合要求的点击进行累加\n            if (this._isValidDistanceFromPrevTap(computed) && this._isValidInterval()) {\n                this.tapCount++;\n            } else {\n                this.tapCount = 1;\n            }\n            // 是否满足点击次数要求\n            // 之所以用%, 是因为如果连续点击3次, 单击的tapCount会为3, 但是其实tap也应该触发\n            if (0 === this.tapCount % this.options.tapTimes) {\n                if (this.hasRequireFailure() && !this.isAllRequireFailureRecognizersDisabled()) {\n                    this.isWaitingOther = true;\n                    this._waitOtherFailedTimer = (setTimeout as Window['setTimeout'])(() => {\n                        // 检查指定手势是否识别为Failed\n                        if (this.isAllRequiresFailedOrPossible()) {\n                            this.status = STATUS_RECOGNIZED;\n                            this.emit(this.options.name, { ...computed, tapCount: this.tapCount });\n                        } else {\n                            this.status = STATUS_FAILED;\n                        };\n                        this.isWaitingOther = false;\n                        // 不论成功失败都要重置tap计数\n                    }, this.options.waitNextTapTime);\n                }\n                // 如果不需要等待其他手势失败\n                // 那么立即执行\n                else {\n                    this.status = STATUS_RECOGNIZED;\n                    this.emit(this.options.name, { ...computed, tapCount: this.tapCount });\n                    this.reset();\n                }\n            } else {\n                this._delayFailTimer = (setTimeout as Window['setTimeout'])(() => {\n                    this.status = STATUS_FAILED;\n                    this.reset();\n                }, this.options.waitNextTapTime);\n            }\n        } else {\n            this.reset();\n            this.status = STATUS_FAILED;\n        }\n    };\n\n    public reset() {\n        this.tapCount = 0;\n        this.prevTapPoint = undefined;\n        this.prevTapTime = undefined;\n    };\n\n    /**\n      * 识别条件\n      * @param {AnyTouchEvent} 计算数据\n      * @return {Boolean} 是否验证成功\n      */\n    public test(computed: AnyTouchEvent): boolean {\n        // 判断是否发生大的位置变化\n        const { distance, deltaTime, maxPointLength } = computed;\n        // 检查\n        // 1. 触点数\n        // 2. 移动距离\n        // 3. start至end的事件, 区分tap和press\n        return maxPointLength === this.options.pointLength &&\n            this.options.positionTolerance >= distance &&\n            this.options.maxPressTime > deltaTime;\n    };\n\n    public afterEmit(computed: AnyTouchEvent): void { }\n};","import { AnyTouchEvent } from '../interface';\nimport {\n    STATUS_FAILED, STATUS_RECOGNIZED\n} from '../const/recognizerStatus';\nimport { INPUT_CANCEL, INPUT_END, INPUT_START } from '../const';\nimport Recognizer from './Base';\n\nexport default class PressRecognizer extends Recognizer {\n    private _timeoutId?: any;\n    static DEFAULT_OPTIONS = {\n        name: 'press',\n        pointLength: 1,\n        positionTolerance: 9,\n        minPressTime: 251,\n    };\n    constructor(options = {}) {\n        super(options);\n    };\n\n    getTouchAction(): string[] {\n        return ['auto'];\n    };\n\n    recognize(computed: AnyTouchEvent): void {\n        const { eventType, deltaTime } = computed;\n        // 1. start阶段\n        // 2. 触点数符合\n        // 那么等待minPressTime时间后触发press\n        if (INPUT_START === eventType && this.test(computed)) {\n            // 重置状态\n            this._resetStatus();\n            // 延迟触发\n            this.cancel();\n            this._timeoutId = (setTimeout as Window['setTimeout'])(() => {\n                this.status = STATUS_RECOGNIZED;\n                this.emit(this.options.name, computed);\n            }, this.options.minPressTime);\n        }\n\n        // 触发pressup条件:\n        // 1. end阶段\n        // 2. 已识别\n        else if (INPUT_END === eventType && STATUS_RECOGNIZED === this.status) {\n            this.emit(`${this.options.name}up`, computed);\n        }\n\n        // 一旦不满足必要条件, 触发失败\n        // 对应cancel和end阶段\n        else if (!this.test(computed) || (this.options.minPressTime > deltaTime && -1 !== [INPUT_END, INPUT_CANCEL].indexOf(eventType))) {\n            this.cancel();\n            this.status = STATUS_FAILED;\n        }\n\n    };\n\n    /**\n     * 是否满足:\n     * 移动距离不大\n     */\n    test({ distance, pointLength }: AnyTouchEvent): boolean {\n        return this.options.positionTolerance > distance && this.isValidPointLength(pointLength);\n    };\n\n    cancel(): void {\n        clearTimeout(this._timeoutId);\n    }\n\n    afterEmit() { }\n};","import { AnyTouchEvent, Computed } from '../interface';\nimport { INPUT_MOVE } from '../const';\nimport Recognizer from './Base';\nimport getHV from '../utils/getHV';\n\nexport default class PanRecognizer extends Recognizer {\n    static DEFAULT_OPTIONS = {\n        name: 'pan',\n        threshold: 10,\n        pointLength: 1,\n        directions: ['up', 'right', 'down', 'left']\n    };\n    constructor(options = {}) {\n        super(options);\n    };\n\n    getTouchAction() {\n        let touchActions = ['auto'];\n        let { hasHorizontal, hasVertical } = getHV(this.options.directions);\n        if (hasHorizontal && hasVertical) {\n            touchActions = ['none'];\n        } else if (!hasHorizontal && hasVertical) {\n            // 没有水平移动\n            touchActions = ['pan-x'];\n        } else if (!hasVertical && hasHorizontal) {\n            // 没有垂直移动\n            touchActions = ['pan-y'];\n        }\n        return touchActions;\n    };\n\n    /**\n     * @param {AnyTouchEvent} 计算数据\n     * @return {Boolean}} .是否是当前手势 \n     */\n    test({ distance, direction, eventType, pointLength }: AnyTouchEvent): boolean {\n        return INPUT_MOVE === eventType &&\n            (this.isRecognized || this.options.threshold < distance) &&\n            this.isValidPointLength(pointLength) &&\n            this.isVaildDirection(direction);\n    };\n\n    /**\n     * 识别后发布panleft等事件\n     * @param {AnyTouchEvent} 计算数据\n     */\n    afterEmit(computed: AnyTouchEvent) {\n        if ('none' !== computed.direction) {\n            this.emit(this.options.name + computed.direction, computed);\n        }\n    };\n\n    afterRecognized(computed: AnyTouchEvent) {\n        this.lockDirection(computed);\n    }\n\n    /**\n     * 移除限制方向的deltaX/Y\n     * @param {AnyTouchEvent} computed \n     */\n    public lockDirection(computed: Computed): Computed {\n        if (undefined === this.options.directions || 0 === this.options.directions.length) return computed;\n        let deltaX = 0;\n        let deltaY = 0;\n        this.options.directions.forEach((direction: string) => {\n            if ('left' === direction && 0 > computed.deltaX) {\n                deltaX = computed.deltaX;\n            } else if ('right' === direction && 0 < computed.deltaX) {\n                deltaX = computed.deltaX;\n            } else if ('down' === direction && 0 < computed.deltaY) {\n                deltaY = computed.deltaY;\n            } else if ('up' === direction && 0 > computed.deltaY) {\n                deltaY = computed.deltaY;\n            }\n        });\n        computed.deltaX = deltaX;\n        computed.deltaY = deltaY;\n        return computed;\n    };\n};","/**\n * 获取数组中方向是否水平/垂直\n * @param {directionString[]} 方向数组, ['left', 'right','up', 'down']\n * \n */\nimport {directionString} from '../interface';\nexport default (directions: [directionString?, directionString?, directionString?, directionString?]): { hasHorizontal: boolean, hasVertical: boolean } => {\n    let hasHorizontal = false;\n    let hasVertical = false;\n    for (let direction of directions) {\n        if (-1 < ['left', 'right'].indexOf(<string>direction)) {\n            hasHorizontal = true;\n            if (hasVertical) break;\n        } else if (-1 < ['up', 'down'].indexOf(<string>direction)) {\n            hasVertical = true;\n            if (hasHorizontal) break;\n        } else {\n            throw new Error('wrong direction!');\n        }\n    };\n    return { hasHorizontal, hasVertical };\n};","import Recognizer from './Base';\nimport { AnyTouchEvent } from '../interface';\nimport { INPUT_END } from '../const';\nexport default class SwipeRecognizer extends Recognizer {\n    static DEFAULT_OPTIONS = {\n        name: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        pointLength: 1,\n        directions: ['up', 'right', 'down', 'left']\n    };\n    constructor(options = {}) {\n        super(options);\n    };\n\n    getTouchAction() {\n        return ['none'];\n    };\n\n    /**\n     * 识别后发布swipeleft等事件\n     * @param {AnyTouchEvent} 计算数据\n     */\n    afterEmit(computed: AnyTouchEvent) {\n        if ('none' !== computed.direction) {\n            this.emit(this.options.name + computed.direction, computed);\n        }\n    };\n\n    /**\n     * 识别条件\n     * @param {AnyTouchEvent} 计算数据\n     */\n    test(computed: AnyTouchEvent): boolean {\n        if (INPUT_END !== computed.eventType) return false;\n\n        // 非end阶段, 开始校验数据\n        const { direction, velocityX, velocityY, maxPointLength, distance } = computed;\n        // 如果只支持水平或垂直, 那么其他方向速率为0;\n        // 有效速率\n        let vaildVelocityX: number = velocityX;\n        let vaildVelocityY: number = velocityY;\n        if (this.isOnlyHorizontal()) {\n            vaildVelocityY = 0;\n        } else if (this.isOnlyVertical()) {\n            vaildVelocityX = 0;\n        }\n\n        let vaildVelocity = Math.sqrt(vaildVelocityX * vaildVelocityX + vaildVelocityY * vaildVelocityY)\n\n        return 1 === maxPointLength &&\n            this.options.threshold < distance &&\n            this.isVaildDirection(direction) &&\n            this.options.velocity < vaildVelocity;\n    };\n};","import { AnyTouchEvent } from '../interface';\nimport Recognizer from './Base';\n\n\nexport default class PinchRecognizer extends Recognizer {\n    private _prevScale: number;\n    static DEFAULT_OPTIONS = {\n        name: 'pinch',\n        // 触发事件所需要的最小缩放比例\n        threshold: 0,\n        pointLength: 2,\n    };\n    constructor(options={}) {\n        super(options);\n        this._prevScale = 1;\n    };\n    \n    getTouchAction(){\n        return ['none'];\n    };\n\n    afterEmit(computed: AnyTouchEvent) {\n        if('end' === computed.eventType) return;\n        // pinchin | pinchout\n        const { scale } = computed;\n        if (1 !== scale) {\n            const inOrOut = scale > this._prevScale ? 'out' : 'in';\n            this.emit(this.options.name + inOrOut, computed);\n        }\n        this._prevScale = scale;\n    };\n\n    /**\n     * 识别条件\n     * @param {AnyTouchEvent} 计算数据\n     * @param {(isRecognized: boolean) => void}} 接收是否识别状态\n     */\n    test({ pointLength, scale }: AnyTouchEvent): boolean {\n        // 如果触碰点数要大于指定\n        // 如果缩放超过阈值, 或者已识别\n        // console.log({scale})\n        return this.isValidPointLength(pointLength) && (this.options.threshold < Math.abs(scale-1) || this.isRecognized);\n    };\n};","import Base from './Base';\nimport { AnyTouchEvent } from '../interface';\nexport default class RotateRecognizer extends Base {\n    static DEFAULT_OPTIONS = {\n        name: 'rotate',\n        // 触发事件所需要的最小角度\n        threshold: 0,\n        pointLength: 2,\n    };\n    constructor(options = {}) {\n        super(options);\n    };\n\n    getTouchAction() {\n        return ['none'];\n    };\n\n    /**\n     * 无特殊事件要触发\n     */\n    afterEmit(computed: AnyTouchEvent) { };\n\n    /**\n     * 识别条件\n     * @param {AnyTouchEvent} 计算数据\n     * @return {Boolean} 接收是否识别状态\n     */\n    test({ pointLength, angle }: AnyTouchEvent): boolean {\n        // 如果触碰点数要大于指定\n        // 如果缩放超过阈值, 或者已识别\n        return this.isValidPointLength(pointLength) && (this.options.threshold < Math.abs(angle) || this.isRecognized);\n    };\n};","/**\n * ==================== 参考 ====================\n * https://segmentfault.com/a/1190000010511484#articleHeader0\n * https://segmentfault.com/a/1190000007448808#articleHeader1\n * hammer.js http://hammerjs.github.io/\n * \n * ==================== 支持的手势 ====================\n * rotate 旋转\n * pinch 捏合,\n * tap 单机\n * doubleTap 双击\n * press 按压\n * pan 拖拽\n * swipe 快划\n * \n * ==================== 流程 ====================\n * 格式化Event成统一的pointer格式 => 通过pointer数据计算 => 用计算结果去识别手势\n */\nimport { AnyTouchEvent, SupportEvent, CSSPreventMap } from './interface';\nimport AnyEvent from 'any-event';\nimport { SUPPORT_TOUCH, NONE } from './const';\nimport InputManage from './InputManage';\nimport computeTouchAction from './utils/computeTouchAction';\nimport Store from './Store';\n\n// 识别器\nimport Recognizer from './recognitions/Base';\nimport Tap from './recognitions/Tap';\nimport Press from './recognitions/Press';\nimport Pan from './recognitions/Pan';\nimport Swipe from './recognitions/Swipe';\nimport Pinch from './recognitions/Pinch';\nimport Rotate from './recognitions/Rotate';\nimport * as Vector from './vector';\ninterface Options {\n    touchAction?: 'compute' | 'auto' | 'manipulation' | 'pan-x' | 'pan-y' | 'none';\n    hasDomEvents?: boolean;\n    isPreventDefault?: boolean;\n    syncToAttr?: boolean;\n    cssPrevent?: {\n        // 阻止触发选择文字\n        selectText?: boolean;\n        // 阻止触发浏览器默认拖拽\n        drag?: boolean;\n        // 隐藏高亮效果\n        tapHighlight?: boolean;\n        // 阻止默认菜单\n        callout?: boolean;\n    }\n};\nexport class AnyTouch {\n    // 识别器\n    static Tap = Tap;\n    static Press = Press;\n    static Pan = Pan;\n    static Swipe = Swipe;\n    static Pinch = Pinch;\n    static Rotate = Rotate;\n    static version = '__VERSION__';\n\n    // 向量计算\n    static Vector = Vector;\n\n    // mini的事件触发器\n    static EventEmitter = AnyEvent;\n\n    // 目标元素\n    el?: HTMLElement;\n\n    default: Options;\n\n    touchDevice: string;\n\n    recognizers: Recognizer[];\n\n    options: Options;\n\n    eventEmitter: AnyEvent;\n\n    inputManage: InputManage;\n\n    $store: Store;\n\n    // 是否阻止后面的识别器运行\n    private _isStopped: boolean;\n\n    /**\n     * @param {Element} 目标元素\n     * @param {Object} 选项\n     */\n    constructor(el?: HTMLElement, options?: Options) {\n        this.default = {\n            touchAction: 'compute',\n            hasDomEvents: true,\n            isPreventDefault: true,\n            syncToAttr: false,\n            cssPrevent: {\n                // 阻止触发选择文字\n                selectText: true,\n                // 阻止触发浏览器默认拖拽\n                drag: true,\n                // 隐藏高亮效果\n                tapHighlight: true,\n                // 阻止默认菜单\n                callout: true\n            }\n        };\n        if (undefined !== el) this.el = el;\n        this.$store = new Store();\n        this.inputManage = new InputManage({ $store: this.$store });\n        this.touchDevice = SUPPORT_TOUCH ? 'touch' : 'mouse';\n        this.options = { ...this.default, ...options };\n        // eventEmitter\n        this.eventEmitter = new AnyEvent();\n        this._isStopped = false;\n        // 识别器\n        // 注入当前方法和属性, 方便在识别器中调用类上的方法和属性\n        this.recognizers = [\n            new Rotate().$injectRoot(this),\n            new Pinch().$injectRoot(this),\n            new Pan().$injectRoot(this),\n            new Swipe().$injectRoot(this),\n            new Tap().$injectRoot(this),\n            new Tap({\n                name: 'doubletap',\n                pointLength: 1,\n                tapTimes: 2,\n                disabled: true\n            }).$injectRoot(this),\n            new Press().$injectRoot(this),\n        ];\n        // 默认单击需要双击识别失败后触发\n        this.recognizers[4].requireFailure(this.recognizers[5]);\n        if (undefined !== this.el) {\n            // 应用设置\n            this.update();\n            // 绑定事件\n            this._unbindEl = this._bindEL(this.el)._unbindEl;\n        }\n    };\n\n    /**\n     * 刷新设备类型, 一般没什么用, 主要为了模拟器下切换pc/手机可以切换识别器\n     * at.refresh();\n     */\n    // refresh() {\n    //     if (undefined === this.el) return;\n    //     this._unbindEl()\n    //     this.touchDevice = ('ontouchstart' in window) ? 'touch' : 'mouse';\n    //     this._unbindEl = this._bindEL(this.el)._unbindEl;\n    // };\n\n    /**\n     * 计算touch-action\n     * @param {HTMLElement} 目标元素 \n     */\n    updateTouchAction() {\n        if ('compute' === this.options.touchAction) {\n            let touchActions = [];\n            for (let recognizer of this.recognizers) {\n                touchActions.push(...recognizer.getTouchAction());\n            };\n            this.el!.style.touchAction = computeTouchAction(touchActions);\n        } else {\n            this.el!.style.touchAction = this.options.touchAction || 'auto';\n        }\n    };\n\n    /**\n     * 设置\"阻止浏览器默认行为\"的css样式\n     */\n    updateCssPrevent() {\n        const style = <CSSPreventMap>{};\n        const { cssPrevent } = this.options;\n        if (undefined === cssPrevent) return;\n        if (cssPrevent.selectText) {\n            style['mozUserSelect'] = NONE;\n            style['userSelect'] = NONE;\n            style['msUserSelect'] = NONE;\n            style['webkitUserSelect'] = NONE;\n            style['msTouchSelect'] = NONE;\n        }\n\n        if (cssPrevent.drag) {\n            style['webkitUserDrag'] = NONE;\n        }\n\n        if (cssPrevent.tapHighlight) {\n            style['webkitTapHighlightColor'] = 'rgba(0,0,0,0)';\n        }\n\n        if (cssPrevent.callout) {\n            style['webkitTouchCallout'] = NONE;\n        }\n        // 设置\n        for (let k in style) {\n            this.el!.style[k] = style[k];\n        }\n    };\n\n    /**\n     * 更新设置\n     */\n    public update() {\n        if (undefined === this.el) return;\n        this.updateTouchAction();\n        this.updateCssPrevent();\n    };\n\n    /**\n     * 绑定手势到指定元素\n     * 暂时只支持事件冒泡阶段触发, \n     * 改为捕获阶段需要对inputListener进行编号, \n     * 产生大量事件绑定,\n     * 而非在一次触发事件中执行所有手势判断\n     * @param {Element} 待绑定手势元素\n     */\n    private _bindEL(el: Element) {\n        const boundInputListener = <EventListener>this.inputListener.bind(this);\n\n        // Touch\n        if ('touch' === this.touchDevice) {\n            const events = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n            events.forEach(eventName => {\n                el.addEventListener(eventName, boundInputListener);\n            });\n            return {\n                _unbindEl: () => {\n                    events.forEach(eventName => {\n                        el.removeEventListener(eventName, boundInputListener);\n                    });\n                }\n            }\n        }\n        // Mouse\n        else {\n            el.addEventListener('mousedown', boundInputListener);\n            window.addEventListener('mousemove', boundInputListener);\n            window.addEventListener('mouseup', boundInputListener);\n            return {\n                _unbindEl: () => {\n                    el.removeEventListener('mousedown', boundInputListener);\n                    window.removeEventListener('mousemove', boundInputListener);\n                    window.removeEventListener('mouseup', boundInputListener);\n                }\n            };\n        }\n    };\n\n    /**\n     * 为微信设计的功能\n     * 接收touch事件的event对象\n     * @param {SupportEvent} 事件对象\n     */\n    useEvent(event: SupportEvent) {\n        this.inputListener(event);\n    };\n\n    /**\n     * 添加识别器\n     * @param recognizer 识别器\n     */\n    add(recognizer: Recognizer): void {\n        recognizer.$injectRoot(this);\n        const hasSameName = this.recognizers.some((theRecognizer: Recognizer) => recognizer.name === theRecognizer.name);\n        if (hasSameName) {\n            this.eventEmitter.emit('error', { code: 1, message: `${recognizer.name}识别器已经存在!` })\n        } else {\n            this.recognizers.push(recognizer);\n            this.update();\n        }\n    };\n\n    /**\n     * 获取识别器通过名字\n     * @param {String} 识别器的名字\n     * @return {Recognizer|undefined} 返回识别器\n     */\n    get(name: string): Recognizer | undefined {\n        return this.recognizers.find(recognizer => name === recognizer.options.name);\n    };\n\n    /**\n     * 设置\n     * @param {Options} 选项 \n     */\n    set(options: Options): void {\n        this.options = { ...this.default, ...options };\n        this.update();\n    };\n\n    /**\n     * 停止识别\n     */\n    stop() {\n        this._isStopped = true;\n    }\n\n    /**\n     * 删除识别器\n     * @param {String} 识别器name\n     */\n    remove(recognizerName: string): void {\n        for (let [index, recognizer] of this.recognizers.entries()) {\n            if (recognizerName === recognizer.options.name) {\n                this.recognizers.splice(index, 1);\n                break;\n            }\n        }\n    };\n\n    /**\n     * 监听input变化\n     * @param {Event}\n     */\n    inputListener(event: SupportEvent): void {\n        if (this.options.isPreventDefault) {\n            event.preventDefault();\n        }\n\n        // if (!event.cancelable) {\n        //     this.eventEmitter.emit('error', { code: 0, message: '页面滚动的时候, 请暂时不要操作元素!' });\n        // }\n\n        // 管理历史input\n        // 生成AnyTouchEvent\n        const computed = this.inputManage.load(event);\n        // 跳过无效输入\n        // 如: 当是鼠标事件的时候, 会有undefined的时候\n        if (undefined !== computed) {\n            // input事件\n            this.emit('input', computed);\n            if (computed.isStart) {\n                // 重置isStopped\n                this._isStopped = false;\n            }\n            // if (computed.isStart) {\n            //     // $store.reset();\n            //     this._isStopped = false;\n            //     this.emit('inputstart', computed);\n            // } else if ('cancel' === computed.eventType) {\n            //     this.emit('inputcancel', computed);\n            // } else if (computed.isEnd) {\n            //     this.emit('inputend', computed);\n            // } else {\n            //     // prevInput和input一定不为空\n            //     if (this.inputManage.prevInput!.pointLength > computed.pointLength) {\n            //         this.emit('inputreduce', computed);\n            //     } else if (this.inputManage.prevInput!.pointLength < computed.pointLength) {\n            //         this.emit('inputadd', computed);\n            //     } else {\n            //         this.emit('inputmove', computed);\n            //     }\n            // };\n\n            for (let recognizer of this.recognizers) {\n                if (recognizer.disabled) continue;\n                // 如果遇到停止标记, 立即停止运行后面的识别器\n                recognizer.recognize(computed);\n                if (this._isStopped) {\n                    break;\n                }\n            }\n        }\n    };\n\n    /**\n     * 注册事件\n     * @param {String} 事件名\n     * @param {Function} 回调函数\n     */\n    on(type: string, listener: (event: AnyTouchEvent) => void, options: { [k: string]: boolean } | boolean = false): void {\n        this.eventEmitter.on(type, listener);\n    };\n\n    /**\n     * 解绑事件\n     * @param {String} 事件名 \n     * @param {Function} 事件回调\n     */\n    off(type: string, listener?: (event: AnyTouchEvent) => void): void {\n        this.eventEmitter.off(type, listener);\n    };\n\n    /**\n     * 触发事件, 同时type会作为payload的一个键值\n     * @param {String} 类型名\n     * @param {Object} 数据\n     */\n    emit(type: string, payload: AnyTouchEvent) {\n        this.eventEmitter.emit(type, { ...payload, type });\n    };\n\n    /**\n     * 解绑所有触摸事件\n     */\n    _unbindEl(): void { };\n\n    /**\n     * 销毁\n     */\n    destroy() {\n        this.$store.destroy();\n        // 解绑事件\n        if (this.el) {\n            this._unbindEl();\n        }\n        this.eventEmitter.destroy();\n    };\n};","export default (touchActions: string[]): string => {\n    // 表示优先级\n    const TOUCH_ACTION_PRIORITY: { [propName: string]: number } = {\n        auto: 0,\n        manipulation: 1,\n        'pan-x': 2,\n        'pan-y': 2,\n        none: 3\n    };\n\n    // 最大优先级\n    const MAX_PRIORITY = TOUCH_ACTION_PRIORITY['none'];\n\n    // 最终的有效的touch-action会放在数组中\n    let touchActionCSSArray: string[] = ['auto'];\n    // 上一步计算的touch-action的优先级\n    let prevPriority = 0;\n    for (let touchAction of touchActions) {\n\n        // 当前优先级\n        let activePriority = TOUCH_ACTION_PRIORITY[touchAction];\n\n        // 如果是最大优先级, 那么后面就不用计算了\n        if (MAX_PRIORITY === activePriority) {\n            touchActionCSSArray = [touchAction];\n            break;\n        }\n        // 当前优先级大, 那么覆盖touch-action\n        else if (prevPriority < activePriority) {\n            touchActionCSSArray = [touchAction];\n            prevPriority = activePriority;\n        }\n        // 如果相等那么加入当前touch-action, 例如pan-x/pan-y可以并存\n        else if (prevPriority === activePriority && 0 < activePriority) {\n            touchActionCSSArray.push(touchAction);\n            prevPriority = activePriority;\n        }\n        \n    }\n    return touchActionCSSArray.join(' ');\n};","// 注意: 由于vue指令没办法对指令进行优先级设置, 所以指令版本并不能实现AnyTouch所有的功能,\n// 比如新建手势. 所以指令版只支持tap/doubletap/pan/swipe/rotate/pinch等默认手势\nimport { AnyTouchEvent } from '../interface';\nimport { VueConstructor } from 'vue/types/vue';\nimport { DirectiveBinding } from 'vue/types/options';\nimport InstanceManage from './InstanceManage';\nimport { AnyTouch } from '../AnyTouch';\n\n// 管理实例和元素的映射关系\nconst iManage = new InstanceManage(AnyTouch);\n// 导出指令\nconst plugin = {\n    install(Vue: VueConstructor) {\n        const _bindEvent = (el: HTMLElement, binding: DirectiveBinding) => {\n            let instance = iManage.getOrCreateInstanceByEl(el);\n            // 导入AnyTouch实例\n            if (undefined !== binding.value) {\n                binding.value(instance);\n            }\n        };\n\n        /**\n         * 解除绑定事件\n         * @param {Element} 关联元素 \n         */\n        const _unbindEvent = (el: HTMLElement) => {\n            const index = iManage.getIndexByEl(el);\n            // 防止一个元素上的多个手势指令会重复触发删除\n            if (-1 !== index && undefined !== iManage.getInstanceByIndex(index)) {\n                iManage.getInstanceByIndex(index).destroy();\n                iManage.removeInstanceByIndex(index);\n            }\n        };\n\n        Vue.directive('touch', {\n            inserted(el, binding) {\n                _bindEvent(el, binding);\n            },\n\n            update(el, binding) {\n                _bindEvent(el, binding);\n            },\n\n            unbind(el) {\n                _unbindEvent(el);\n            }\n        });\n    }\n};\n\n// if('test' !== process.env.NODE_ENV){\n    \n// }\n// 自动加载插件\n// if (typeof <any>window !== 'undefined' && (<any>window).Vue) {\n//     (<any>window).Vue.use(plugin);\n// };\n\nexport default plugin;\n","/**\n * 管理实例和元素的映射关系\n * 一个元素只能对应一个实例\n */\nexport default class <T extends { new(...arys: any): any }> {\n    // 存储映射关系\n    stock: { el: HTMLElement, instance: InstanceType<T> }[] = [];\n    ClassObject: T;\n\n    constructor(ClassObject: T) {\n        this.stock = [];\n        this.ClassObject = ClassObject;\n    };\n\n    /**\n    * 获取元素在stock中的索引\n    * @param {Element} 元素 \n    * @returns {Number} 元素索引 \n    */\n    getIndexByEl(el: HTMLElement): number {\n        for (let i = 0, len = this.stock.length; i < len; i++) {\n            if (el === this.stock[i].el) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * 获取实例\n     * @param {Number} 索引\n     * @return {InstanceType<T>} 实例 \n     */\n    getInstanceByIndex(index: number): InstanceType<T> {\n        return this.stock[index]!.instance;\n    };\n\n    /**\n     * 删除指定实例\n     * @param {Number} 索引\n     */\n    removeInstanceByIndex(index: number): void {\n        this.stock.splice(index, 1);\n    };\n\n    /**\n     * 获取实例, 如果没有新建\n     * @param {Element} 目标元素\n     * @param {InstanceType<T>}  InstanceType<T>实例\n     */\n    getOrCreateInstanceByEl(el: HTMLElement): InstanceType<T> {\n        const manageIndex = this.getIndexByEl(el);\n        // 防止同一个元素上同一个指令实例化多个InstanceType<T>\n        if (-1 === manageIndex) {\n            // 新建实例\n            const instance = new this.ClassObject(el);\n            this.stock.push({el, instance});\n            return instance;\n        } else {\n            return this.getInstanceByIndex(manageIndex);\n        }\n    };\n};","import { AnyTouch } from './AnyTouch';\nimport VueDirective from './vueDirective';\nexport default class extends AnyTouch {\n    // vue指令版\n    static vTouch = VueDirective;\n}"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__values","o","m","Symbol","iterator","next","value","done","__read","r","e","ar","push","error","return","__spread","concat","_listenersMap","AnyEvent","eventName","listener","isOnce","on","listeners","index","findIndex","fn","splice","_i","payload","_b","tslib_1.__values","entries","_d","listenerClone","eventNames","getEventNames","SUPPORT_TOUCH","window","CLIENT_X","CLIENT_Y","INPUT_CANCEL","INPUT_END","NONE","getVLength","v","Math","sqrt","x","y","getDotProduct","v1","v2","getRadian","mr","acos","getCross","getAngle","angle","radianToAngle","radian","PI","getCenter","points","countPoint","reduce","point","round","getDirection","abs","tslib_1.__extends","default_1","event","from","touches","map","_a","clientX","clientY","changedPoints","changedTouches","eventType","type","replace","nativeEvent","Adapter","_super","_this","isPressed","button","prevPoints","mousedown","mousemove","mouseup","adapter","Touch","Mouse","BASE_INPUT","load","pointLength","changedPointLength","isStart","isEnd","_center","timestamp","Date","now","target","currentTarget","preventDefault","center","$store","prevInput","input","velocityX","velocityY","speedX","speedY","direction","_prevInput","deltaTime","indexOf","get","deltaX","deltaY","set","maxPointLength","startMultiInput","startV","computeVector","prevV","activeV","deltaScale","scale","_c","deltaAngle","inputFactory","InputFactory","inputs","startInput","displacementX","displacementY","distanceX","distanceY","distance","overallDirection","deltaXYAngle","deltaXY","pow","computeMaxLength","compute","_record","activeInput","store","object","key","defaultValue","reset","STATUS_POSSIBLE","STATUS_START","STATUS_MOVE","STATUS_END","STATUS_CANCELLED","STATUS_FAILED","STATUS_RECOGNIZED","options","DEFAULT_OPTIONS","disabled","name","status","isRecognized","requireFailureRecognizers","isWaitingOther","Recognizer","$root","update","eventEmitter","emit","el","syncToAttr","setAttribute","hasDomEvents","type_1","data","getOwnPropertySymbols","propertyIsEnumerable","Event","dispatchEvent","recognizer","includes","every","isOnlyHorizontal","directions","isOnlyVertical","isVaild","activeStatus","touchDevice","STATE_MAP","1","move","0","_e","_f","_g","Number","computed","test","_resetStatus","flow","afterRecognized","afterEmit","tapCount","TapRecognizer","tapTimes","prevTapPoint","distanceFromPreviousTap","tapsPositionTolerance","prevTapTime","interval","waitNextTapTime","clearTimeout","_delayFailTimer","_waitOtherFailedTimer","_isValidDistanceFromPrevTap","_isValidInterval","hasRequireFailure","isAllRequireFailureRecognizersDisabled","setTimeout","isAllRequiresFailedOrPossible","positionTolerance","maxPressTime","PressRecognizer","cancel","_timeoutId","minPressTime","isValidPointLength","PanRecognizer","touchActions","hasHorizontal","hasVertical","directions_1","Error","threshold","isVaildDirection","lockDirection","forEach","SwipeRecognizer","vaildVelocityX","vaildVelocityY","vaildVelocity","velocity","_prevScale","PinchRecognizer","inOrOut","RotateRecognizer","Base","default","touchAction","isPreventDefault","cssPrevent","selectText","drag","tapHighlight","callout","Store","inputManage","InputManage","_isStopped","recognizers","Rotate","$injectRoot","Pinch","Pan","Swipe","Tap","Press","requireFailure","_unbindEl","_bindEL","AnyTouch","getTouchAction","style","TOUCH_ACTION_PRIORITY","auto","manipulation","pan-x","pan-y","none","MAX_PRIORITY","touchActionCSSArray","prevPriority","touchActions_1","activePriority","join","k","mozUserSelect","userSelect","msUserSelect","webkitUserSelect","msTouchSelect","webkitUserDrag","webkitTapHighlightColor","webkitTouchCallout","updateTouchAction","updateCssPrevent","boundInputListener","inputListener","bind","events_1","addEventListener","removeEventListener","some","theRecognizer","code","message","find","recognizerName","recognize","off","destroy","Vector","iManage","ClassObject","stock","len","instance","manageIndex","getIndexByEl","getInstanceByIndex","plugin","install","Vue","_bindEvent","binding","getOrCreateInstanceByEl","directive","inserted","unbind","removeInstanceByIndex","VueDirective"],"mappings":"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"}