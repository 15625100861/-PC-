{"version":3,"file":"AnyTouch.es.js","sources":["../node_modules/_any-event@0.3.4@any-event/dist/AnyEvent.es.js","../src/const.ts","../src/vector.ts","../src/input/adapters/touch.ts","../src/input/adapters/mouse.ts","../src/input/create.ts","../src/inputManage.ts","../src/compute/computeLast.ts","../src/compute/computeDistance.ts","../src/compute/computeDeltaXY.ts","../src/compute/computeVector.ts","../src/compute/computeScale.ts","../src/compute/computeAngle.ts","../src/compute/computeMaxLength.ts","../src/compute/index.ts","../src/untils/computeTouchAction.ts","../src/const/recognizerStatus.ts","../src/recognitions/Base.ts","../src/recognitions/Tap.ts","../src/recognitions/Press.ts","../src/untils/getHV.ts","../src/recognitions/Pan.ts","../src/recognitions/Swipe.ts","../src/recognitions/Pinch.ts","../src/recognitions/Rotate.ts","../src/main.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        this._listenersMap = {};\n    }\n    EventEmitter.prototype.on = function (eventName, listener) {\n        if (undefined === this._listenersMap[eventName]) {\n            this._listenersMap[eventName] = [];\n        }\n        this._listenersMap[eventName].push(listener);\n        return this;\n    };\n    EventEmitter.prototype.once = function (eventName, listener) {\n        listener.isOnce = true;\n        this.on(eventName, listener);\n        return this;\n    };\n    EventEmitter.prototype.off = function (eventName, listener) {\n        var listeners = this._listenersMap[eventName];\n        if (undefined !== listeners) {\n            if (undefined === listener) {\n                delete this._listenersMap[eventName];\n            }\n            else {\n                var index = listeners.findIndex(function (fn) { return fn === listener; });\n                listeners.splice(index, 1);\n            }\n        }\n        return this;\n    };\n    EventEmitter.prototype.emit = function (eventName) {\n        var payload = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            payload[_i - 1] = arguments[_i];\n        }\n        var e_1, _a;\n        var listeners = this._listenersMap[eventName];\n        if (undefined !== listeners && 0 < listeners.length) {\n            try {\n                for (var _b = __values(listeners.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var _d = __read(_c.value, 2), index = _d[0], listener = _d[1];\n                    if (listener.isOnce) {\n                        var listenerClone = listener;\n                        listeners.splice(index, 1);\n                        listenerClone.apply(void 0, __spread(payload));\n                    }\n                    else {\n                        listener.apply(void 0, __spread(payload));\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b[\"return\"])) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    EventEmitter.prototype.has = function (eventName) {\n        return undefined !== this._listenersMap[eventName] && 0 < this._listenersMap[eventName].length;\n    };\n    EventEmitter.prototype.destroy = function () {\n        this._listenersMap = {};\n    };\n    return EventEmitter;\n}());\n\nexport default EventEmitter;\n","// 简单判断是否手机设备\nexport const MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n// console.log('ua', navigator.userAgent);\n// 是否手机设备\nexport const IS_MOBILE = MOBILE_REGEX.test(navigator.userAgent);\n\n// 是否支持touch事件\nexport const SUPPORT_TOUCH = ('ontouchstart' in window);\n// 是否是移动设备\nexport const SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\n// 方向\nexport const DIRECTION_NONE = 1; // 0000 0001\nexport const DIRECTION_LEFT = 2; //  0000 0010\nexport const DIRECTION_RIGHT = 4; // 0000 0100 \nexport const DIRECTION_UP = 8; // 0000 1000\nexport const DIRECTION_DOWN = 16; // 0001 0000\n\n// 位运算 求值 对上上面的4个方向可以简单理解为\"+\"\nexport const DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT; // 6\nexport const DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN; // 24\nexport const DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL; // 30\n\n// 计算触发时间间隔, 防止事件触发就一直计算\nexport const COMPUTE_INTERVAL = 25;\n\n\n// 计算时候取touchs.clientX | clientY\nexport const propX = 'clientX';\nexport const propY = 'clientY';\nexport const CLIENT_X = 'clientX';\nexport const CLIENT_Y = 'clientY';\n\n\n// 识别器状态码\nexport const RECOGNIZER_STATUS_POSSIBLE = 1;\nexport const RECOGNIZER_STATUS_BEGAN = 2;\nexport const RECOGNIZER_STATUS_CHANGED = 4;\nexport const RECOGNIZER_STATUS_ENDED = 8;\nexport const RECOGNIZER_STATUS_RECOGNIZED = RECOGNIZER_STATUS_ENDED;\nexport const RECOGNIZER_STATUS_CANCELLED = 16;\nexport const RECOGNIZER_STATUS_FAILED = 32;\n\n// input的类型\nexport const INPUT_START = 'start';\nexport const INPUT_MOVE = 'move';\nexport const INPUT_CANCEL = 'cancel';\nexport const INPUT_END = 'end';\n","import { propX, propY } from './const';\ninterface Vector {\n    x: number;\n    y: number;\n}\nconst { round } = Math;\n/**\n * 获取向量长度(向量模)\n * @param {Object} 向 量\n */\nexport const getVLength = (v: Vector): number => {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n}\n\n/**\n * 点积\n * @param {Object} v1\n * @param {Object} v2\n */\nexport const getDotProduct = (v1: Vector, v2: Vector) => {\n    return v1.x * v2.x + v1.y * v2.y;\n}\n\n/**\n * 向量夹角(弧度)\n * @param {Object} v1\n * @param {Object} v2\n */\nexport const getRadian = (v1: Vector, v2: Vector) => {\n    var mr = getVLength(v1) * getVLength(v2);\n    if (mr === 0) return 0;\n    var r = getDotProduct(v1, v2) / mr;\n    if (r > 1) r = 1;\n    return Math.acos(r);\n}\n\n/**\n * 求旋转方向\n * 顺时针/逆时针\n */\nexport const getCross = (v1: Vector, v2: Vector) => {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\n/**\n * 向量夹角(角度)\n * @param {Object} v1\n * @param {Object} v2\n */\nexport const getAngle = (v1: Vector, v2: Vector) => {\n    var angle = getRadian(v1, v2);\n    if (getCross(v1, v2) > 0) {\n        angle *= -1;\n    }\n    return radianToAngle(angle);\n};\n\n/**\n * 弧度转角度\n * @param {Number} 弧度 \n */\nexport const radianToAngle = (radian: number): number => radian / Math.PI * 180;\n\n/**\n * 角度转弧度\n * @param {Number} 角度 \n */\nexport const angleToRadian = (angle: number): number => angle / 180 * Math.PI;\n\n/**\n * 获取多点之间的中心坐标\n * @param {Array} 触碰点 \n */\nexport const getCenter = (points: any) => {\n    const pointLength = points.length;\n    if (1 < pointLength) {\n        let x = 0;\n        let y = 0;\n        let i = 0;\n        while (i < pointLength) {\n            x += points[i][propX];\n            y += points[i][propY];\n            i++;\n        }\n\n        return {\n            x: round(x / pointLength),\n            y: round(y / pointLength)\n        };\n    } else {\n        return { x: round(points[0][propX]), y: round(points[0][propY]) };\n    }\n};\n\n/**\n * \n * @param {Number} 事件开始到结束的X位移 \n* @param {Number} 事件开始到结束的Y位移 \n */\nexport const getDirection = (x: number, y: number): string | void => {\n    if (x === y) {\n        return 'none';\n    } else if (Math.abs(x) > Math.abs(y)) {\n        return 0 < x ? 'right' : 'left';\n    } else {\n        return 0 < y ? 'down' : 'up';\n    }\n};\n","export default (event: TouchEvent): any => {\n    // const pointers = event.targetTouches;\n    const pointers = Array.from(event.touches).map(({clientX,clientY})=>({clientX,clientY}));\n    const changedPointers = Array.from(event.changedTouches).map(({clientX,clientY})=>({clientX,clientY}));\n    const eventType = event.type.replace('touch', '');\n    return {\n        eventType,\n        changedPointers,\n        pointers,\n        nativeEvent: event,\n    };\n}; ","import { BaseInput, eventType } from '../../interface';\nlet prevPointers: { clientX: number, clientY: number }[];\nlet isPressed = false;\n// 默认MouseEvent中对type声明仅为string\nexport default (event: MouseEvent): BaseInput | void => {\n    let { clientX, clientY, type, button } = event;\n\n    // changedPointers = prevPointers其实并不能完全等于touch下的changedPointers\n    // 但是由于鼠标没有多点输入的需求, \n    // 所以暂时如此实现\n    const changedPointers = prevPointers || [{ clientX, clientY }];\n\n    let pointers = [{ clientX, clientY }];\n    prevPointers = [{ clientX, clientY }];\n\n    // 必须左键\n    if ('mousedown' === type) {\n        if (0 === button) {\n            isPressed = true;\n        } else {\n            return;\n        }\n    }\n\n    if ('mousemove' === type) {\n        if (!isPressed) return;\n        // 确保移动过程中, 一直按住的都是左键,\n        // if(1 !== event.which) {\n        //     type = 'mouseup'\n        // }\n    } else if ('mouseup' === type) {\n        if (isPressed) {\n            pointers = [];\n        } else {\n            return;\n        };\n        isPressed = false;\n    }\n\n    const MAP = {\n        mousedown: 'start',\n        mousemove: 'move',\n        mouseup: 'end'\n    };\n\n    return {\n        eventType: <eventType>MAP[<'mousedown' | 'mousemove' | 'mouseup'>type],\n        changedPointers,\n        pointers,\n        nativeEvent: event\n    };\n}; ","/**\n * 构造统一的Input格式\n */\nimport { Input, BaseInput, Point } from '../interface';\nimport { SUPPORT_TOUCH, INPUT_END, INPUT_START, INPUT_CANCEL } from '../const';\nimport { getCenter } from '../vector';\nimport touchAdapter from './adapters/touch'\nimport mouseAdapter from './adapters/mouse';\n\n// 缓存触点中心\nlet _center: Point;\n\nexport default (event: Event): Input | void => {\n    // 通过TouchEvent|MouseEvent获取的直接数据\n    let baseInput: BaseInput;\n\n    // Touch\n    if (SUPPORT_TOUCH) {\n        baseInput = touchAdapter(<TouchEvent>event);\n    }\n    // Mouse\n    else {\n        baseInput = <BaseInput>mouseAdapter(<MouseEvent>event);\n        if (undefined === baseInput) {\n            return;\n        }\n    }\n    const { eventType, pointers, changedPointers } = baseInput;\n    // 当前触点数\n    const pointLength: number = pointers.length;\n\n    // 变化前触点数\n    const changedpointLength: number = changedPointers.length;\n    // 识别流程的开始和结束标记\n    const isFirst = (INPUT_START === eventType) && (0 === changedpointLength - pointLength);\n    const isFinal = (INPUT_END === eventType || INPUT_CANCEL === eventType) && (0 === pointLength);\n\n    // 中心坐标\n    if (0 < pointLength) {\n        _center = getCenter(baseInput.pointers);\n    }\n\n    // 当前时间\n    const timestamp = Date.now();\n\n    // 原生属性/方法\n    const { target, currentTarget } = event;\n    const { x, y } = <Point>(_center || {});\n    return {\n        ...baseInput,\n        preventDefault: ()=>{\n            event.preventDefault();\n        },\n        isFirst,\n        isFinal,\n        pointLength,\n        changedpointLength,\n        center: _center,\n        x, y,\n        timestamp,\n        target,\n        currentTarget,\n        nativeEvent: event\n    };\n}","import { Input } from './interface';\nimport createInput from './input/create';\n// 起点(单点|多点)\nlet startInput: Input | undefined;\n// 前一次的触电\nlet prevInput: Input | undefined;\n// 当前触点\nlet activeInput: Input | undefined;\n// 多点触碰的起点\nlet startMutliInput: Input | undefined;\nexport default (event: Event): any => {\n    // 格式化不同设备输入数据\n    const input = createInput(event);\n\n    // 无效的输入    \n    if (undefined === input) return;\n\n    // 当前输入状态\n    const { eventType } = input;\n    // [Start]\n    if ('start' === eventType) {\n        // 上一步的触点\n        // prevInput = undefined;\n        // 当前点\n        activeInput = input;\n        // 起点(单点|多点)\n        startInput = input;\n        // 起点(多点)\n        if (1 < input.pointLength) {\n            startMutliInput = input;\n        } else {\n            // 如果出现了单点, 那么之前的多点起点记录失效\n            startMutliInput = undefined;\n        }\n    } else if ('move' === eventType) {\n        // 读取上一点\n        prevInput = activeInput;\n        activeInput = input;\n    } else if ('end' === eventType) {\n        prevInput = activeInput;\n        activeInput = input;\n    }\n    return {\n        startMutliInput,\n        startInput,\n        prevInput,\n        input\n    };\n}; ","// 返回最近一个时间段的计算结果\n// 默认间隔25ms做一次计算, 让数据更新,\n// 让end阶段读取上一步的计算数据, 比如方向, 速率等...\n// 防止快速滑动到慢速滑动的手势识别成swipe\nimport { Input } from '../interface';\nimport { COMPUTE_INTERVAL, INPUT_CANCEL } from '../const';\nimport { getDirection } from '../vector';\n// 上次采集的input\nlet _prevInput: Input;\n// 上次采集时的瞬时速度\nlet _prevVelocityX: number;\nlet _prevVelocityY: number;\n// 上次采集的方向\nlet _prevDirection: string;\n\nexport default (input: Input): { velocityX: number, velocityY: number, direction?: string } => {\n    // 速率\n    let velocityX: number;\n    let velocityY: number;\n    // 方向\n    let direction: string;\n\n    // _prevInput || input用来保证deltaX等不会有undefined参与计算\n    _prevInput = _prevInput || input;\n    const deltaTime = input.timestamp - _prevInput.timestamp;\n    const deltaX = (0 < input.x) ? input.x - _prevInput.x : 0;\n    const deltaY = (0 < input.y) ? input.y - _prevInput.y : 0;\n    // 每25ms刷新速度数据\n    if (INPUT_CANCEL !== input.eventType && COMPUTE_INTERVAL < deltaTime || undefined === _prevDirection) {\n        velocityX = Math.round(Math.abs(deltaX / deltaTime) * 100) / 100;\n        velocityY = Math.round(Math.abs(deltaY / deltaTime) * 100) / 100;\n        direction = getDirection(deltaX, deltaY) || _prevDirection;\n        // 存储状态\n        _prevVelocityX = velocityX;\n        _prevVelocityY = velocityY;\n        _prevDirection = direction;\n        _prevInput = input;\n    } else {\n        velocityX = _prevVelocityX || 0;\n        velocityY = _prevVelocityY || 0;\n        direction = _prevDirection;\n    }\n\n    return {velocityX, velocityY, direction };\n};","\nlet prevDisplacementX = 0;\nlet prevDisplacementY = 0;\nimport { propX, propY } from '../const';\nimport { getVLength } from '../vector';\nexport default function ({\n    startInput,\n    input\n}: any): any {\n    const { eventType } = input;\n    const { round, abs } = Math;\n    let displacementX = 0;\n    let displacementY = 0;\n    if ('start' === eventType) {\n        prevDisplacementX = prevDisplacementY = 0;\n    } else if ('move' === eventType) {\n        displacementX = round(input.pointers[0][propX] - startInput.pointers[0][propX]);\n        displacementY = round(input.pointers[0][propY] - startInput.pointers[0][propY]);\n\n        // 记录本次位移\n        prevDisplacementX = displacementX;\n        prevDisplacementY = displacementY;\n    } else if ('end' === eventType) {\n        displacementX = prevDisplacementX;\n        displacementY = prevDisplacementY;\n    }\n\n    let distanceX = abs(displacementX);\n    let distanceY = abs(displacementY);\n    let distance = round(getVLength({ x: distanceX, y: distanceY }));\n    return {\n        displacementX, displacementY, distanceX, distanceY, distance\n    };\n};","import { radianToAngle } from '../vector';\nlet lastDeltaXYAngle = 0;\nexport default function ({\n    prevInput,\n    input\n}: any): { deltaX: number, deltaY: number, deltaXYAngle: number } {\n    // 每次事件触发时位移的变化\n    let deltaX: number;\n    let deltaY: number;\n    // deltaX/Y与2者合位移的角度\n    let deltaXYAngle: number = 0;\n\n    // 计算deltaX/Y\n    if ('end' === input.eventType || 'start' === input.eventType) {\n        deltaX = 0;\n        deltaY = 0;\n    } else {\n        deltaX = input.x - prevInput.x;\n        deltaY = input.y - prevInput.y;\n    }\n\n    // 计算deltaXAngle / deltaYAngle\n    if (0 !== deltaX || 0 !== deltaY) {\n        const deltaXY = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n        deltaXYAngle = Math.round(radianToAngle(Math.acos(Math.abs(deltaX) / deltaXY)));\n        lastDeltaXYAngle = deltaXYAngle;\n    } else {\n        deltaXYAngle = lastDeltaXYAngle;\n    }\n\n    return { deltaX, deltaY, deltaXYAngle };\n};","import { propX, propY } from '../const';\nexport default (input: any): { x: number, y: number } => ({\n    x: input.pointers[1][propX] - input.pointers[0][propX],\n    y: input.pointers[1][propY] - input.pointers[0][propY]\n});","import { getVLength } from '../vector';\nexport default function ({\n    startV, prevV, activeV\n}: any): { scale: number, deltaScale: number } {\n    const deltaScale = getVLength(activeV) / getVLength(prevV);\n    const scale = getVLength(activeV) / getVLength(startV);\n    return { scale, deltaScale };\n};","import { getAngle } from '../vector';\nexport default function ({\n    startV, prevV, activeV\n}: any): { angle: number, deltaAngle: number } {\n    const deltaAngle = getAngle(activeV, prevV);\n    const angle = getAngle(activeV, startV);\n    return { angle, deltaAngle };\n};","import { Input } from '../interface';\nlet maxLength = 0;\nexport default ({ pointLength, isFirst, isFinal }: Input): number => {\n    if (isFirst) {\n        maxLength = pointLength;\n    } else {\n        maxLength = Math.max(maxLength, pointLength);\n    }\n    return maxLength;\n};","\nimport { Computed, directionString } from '../interface';\nimport { getDirection, getCenter } from '../vector';\nimport computeLast from './computeLast';\nimport computeDistance from './computeDistance';\nimport computeDeltaXY from './computeDeltaXY';\nimport computeVector from './computeVector';\nimport computeScale from './computeScale';\nimport computeAngle from './computeAngle';\nimport computeMaxLength from './computeMaxLength';\n\nlet prevScale = 1;\nlet prevAngle = 0;\n\n// 最大触点数\nexport default function ({\n    startInput,\n    prevInput,\n    startMutliInput,\n    input\n}: any): Computed {\n    // ========= 整体距离/位移=========\n    const { displacementX, displacementY, distanceX, distanceY, distance } = computeDistance({\n        startInput,\n        input\n    });\n\n    // ========= 方向 =========\n    const overallDirection = <directionString>getDirection(displacementX, displacementY);\n\n    // ========= 已消耗时间 =========\n    const deltaTime = input.timestamp - startInput.timestamp;\n\n    // ========= 最近25ms内计算数据, 瞬时数据 =========\n    const lastComputed = computeLast(input);\n    const velocityX = lastComputed.velocityX;\n    const velocityY = lastComputed.velocityY;\n    const direction = <directionString>lastComputed.direction;\n\n\n    // ========= 中心点位移增量 =========\n    let { deltaX, deltaY, deltaXYAngle } = computeDeltaXY({ input, prevInput });\n\n\n    // ========= 多点计算 =========\n    // 上一触点数大于1, 当前触点大于1\n    let scale = 1;\n    let deltaScale = 0;\n    let angle = 0;\n    let deltaAngle = 0;\n    if (undefined !== prevInput && 1 < prevInput.pointers.length && 1 < input.pointers.length) {\n        // 2指形成的向量\n        const startV = computeVector(startMutliInput);\n        const prevV = computeVector(prevInput);\n        const activeV = computeVector(input);\n        // 计算缩放\n        const scaling = computeScale({\n            startV, activeV, prevV\n        });\n        scale = scaling.scale;\n        deltaScale = scaling.deltaScale;\n\n        // ========= 计算旋转角度 =========\n        const rotation = computeAngle({ startV, prevV, activeV });\n        angle = rotation.angle;\n        deltaAngle = rotation.deltaAngle;\n        prevAngle = angle;\n        prevScale = scale;\n    } else {\n        scale = prevScale;\n        deltaScale = 1;\n        angle = prevAngle;\n        deltaAngle = 0;\n    }\n\n    // ========= 最大触点数 =========\n    return {\n        ...input,\n        velocityX,\n        velocityY,\n        deltaTime,\n        overallDirection,\n        direction,\n        deltaX, deltaY, deltaXYAngle,\n        displacementX,\n        displacementY,\n        distanceX,\n        distanceY,\n        distance,\n        scale,\n        deltaScale,\n        angle,\n        deltaAngle,\n        maxpointLength: computeMaxLength(input)\n    };\n};","export default (touchActions: string[]): string => {\n    // 表示优先级\n    const TOUCH_ACTION_PRIORITY: { [propName: string]: number } = {\n        auto: 0,\n        manipulation: 1,\n        'pan-x': 2,\n        'pan-y': 2,\n        none: 3\n    };\n\n    // 最大优先级\n    const MAX_PRIORITY = TOUCH_ACTION_PRIORITY['none'];\n\n    // 最终的有效的touch-action会放在数组中\n    let touchActionCSSArray: string[] = ['auto'];\n    // 上一步计算的touch-action的优先级\n    let prevPriority = 0;\n    for (let touchAction of touchActions) {\n\n        // 当前优先级\n        let activePriority = TOUCH_ACTION_PRIORITY[touchAction];\n\n        // 如果是最大优先级, 那么后面就不用计算了\n        if (MAX_PRIORITY === activePriority) {\n            touchActionCSSArray = [touchAction];\n            break;\n        }\n        // 当前优先级大, 那么覆盖touch-action\n        else if (prevPriority < activePriority) {\n            touchActionCSSArray = [touchAction];\n            prevPriority = activePriority;\n        }\n        // 如果相等那么加入当前touch-action, 例如pan-x/pan-y可以并存\n        else if (prevPriority === activePriority && 0 < activePriority) {\n            touchActionCSSArray.push(touchAction);\n            prevPriority = activePriority;\n        }\n        \n    }\n    return touchActionCSSArray.join(' ');\n};","// 识别器状态码\nexport const STATUS_POSSIBLE = 'possible';\nexport const STATUS_START = 'start';\nexport const STATUS_MOVE = 'move';\nexport const STATUS_END = 'end';\nexport const STATUS_CANCELLED = 'cancel';\nexport const STATUS_FAILED = 'failed';\nexport const STATUS_RECOGNIZED = 'recognized';","import { Computed, directionString } from '../interface';\nimport { INPUT_CANCEL, INPUT_END, INPUT_MOVE } from '../const';\nimport {\n    STATUS_POSSIBLE,\n    STATUS_START,\n    STATUS_MOVE,\n    STATUS_END,\n    STATUS_CANCELLED,\n    STATUS_FAILED, STATUS_RECOGNIZED\n} from '../const/recognizerStatus';\n\nexport default abstract class Recognizer {\n    // 手势名\n    public name: string;\n    // 是否禁止\n    public disabled: boolean;\n    // 识别状态\n    public status: string;\n    // 是否已识别\n    public isRecognized: boolean;\n    // 选项\n    public options: { [propName: string]: any };\n    // 需要对应手势失败才能识别成功\n    public requireFailureRecognizers: any[];\n    // 存储外部注入方法的容器\n    public $root: any;\n\n    public eventEmitter: any;\n\n    constructor(options: { name?: string, [k: string]: any }) {\n        this.options = { ...(<any>this.constructor).DEFAULT_OPTIONS, disabled: false, ...options };\n        this.name = this.options.name;\n        this.disabled = this.options.disabled;\n        this.status = STATUS_POSSIBLE;\n        this.isRecognized = false;\n        this.requireFailureRecognizers = [];\n        // 这里面不能直接调用$root等, \n        // 因为rollup生成的代码构造函数并不是该constructor\n        // 而是构造函数中又嵌套了一个同名构造函数\n    };\n\n    /**\n     * 设置识别器\n     * @param {Object} 选项 \n     */\n    public set(options = {}) {\n        this.options = { ...this.options, ...options };\n        // 刷新anyTouch\n        this.$root.update();\n        return this;\n    };\n\n    public $injectRoot($root: any) {\n        this.$root = $root;\n        return this;\n    }\n\n    /**\n     * 对eventEmitter进行封装\n     * @param type \n     * @param payload \n     */\n    public emit(type: string, payload: any) {\n        payload.type = type;\n        this.$root.eventEmitter.emit(type, payload);\n        if (this.$root.options.hasDomEvents) {\n            // 过滤掉几个Event上保留的字段\n            let { target, currentTarget, type, ...data } = payload;\n            let event = new Event(type, payload);\n            Object.assign(event, data);\n            this.$root.el.dispatchEvent(event);\n        }\n    };\n\n    /**\n     * 前者需要后者识别失败才能触发\n     * @param {Recognizer} 识别器实例 \n     */\n    public requireFailure(recognizer: this) {\n        if (!this.requireFailureRecognizers.includes(recognizer)) {\n            this.requireFailureRecognizers.push(recognizer);\n        }\n    };\n\n    /**\n     * 移除识别器之间的\"需要失败\"关系\n     *  @param {Recognizer} 识别器实例 \n     */\n    public removeRequireFailure(recognizer: this) {\n        for (let [index, requireFailureRecognizer] of this.requireFailureRecognizers.entries()) {\n            if (requireFailureRecognizer.name === recognizer.name) {\n                this.requireFailureRecognizers.splice(index, 1);\n                break;\n            }\n        }\n    };\n\n    public hasRequireFailure() {\n        return 0 < this.requireFailureRecognizers.length;\n    };\n\n    /**\n     * 是否要求注册时指定失败的选择器是失败状态\n     */\n    public isTheOtherFailed(): boolean {\n        for (let recognizer of this.requireFailureRecognizers) {\n            if (STATUS_FAILED !== recognizer.status && STATUS_POSSIBLE !== recognizer.status) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * 验证触点\n     * @param {Number} 触点数\n     */\n    public isValidPointLength(pointLength: number): boolean {\n        return 0 === this.options.pointLength || this.options.pointLength === pointLength\n    };\n\n    /**\n     * 是否只支持水平方向\n     */\n    public isOnlyHorizontal() {\n        let isOnlyHorizontal = true;\n        for (let direction of this.options.directions) {\n            isOnlyHorizontal = -1 < ['left', 'right'].indexOf(direction);\n            if (!isOnlyHorizontal) {\n                return false;\n            }\n        }\n        return isOnlyHorizontal;\n    };\n\n    /**\n     * 是否只支持垂直方向\n     */\n    public isOnlyVertical() {\n        let isOnlyVertical = true;\n        for (let direction of this.options.directions) {\n            isOnlyVertical = -1 < ['up', 'down'].indexOf(direction);\n            if (!isOnlyVertical) {\n                return false;\n            }\n        }\n        return isOnlyVertical;\n    };\n\n    /**\n     * 是否支持该方向\n     * @param {String} 方向 \n     */\n    public isVaildDirection(direction?: directionString) {\n        return -1 !== this.options.directions.indexOf(direction) || 'none' === direction;\n    };\n\n    public flow(isVaild: boolean, activeStatus: string, inputType: string): string {\n        // if(this.name ==='swipe' ) {\n        //     console.log(isVaild, activeStatus, inputType);\n        // }\n        const STATE_MAP: { [k: number]: any } = {\n            // isVaild === true,\n            // Number(true) === 1\n            // 这个分支不会出现STATUS_FAILED\n            // STATUS_END在上面的代码中也会被重置为STATUS_POSSIBLE, 从而进行重新识别\n            1: {\n                [STATUS_POSSIBLE]: {\n                    [INPUT_MOVE]: STATUS_START,\n                    [INPUT_END]: STATUS_RECOGNIZED,\n                    [INPUT_CANCEL]: STATUS_CANCELLED\n                },\n                [STATUS_START]: {\n                    [INPUT_MOVE]: STATUS_MOVE,\n                    [INPUT_END]: STATUS_END,\n                    [INPUT_CANCEL]: STATUS_CANCELLED\n                },\n                [STATUS_MOVE]: {\n                    [INPUT_MOVE]: STATUS_MOVE,\n                    [INPUT_END]: STATUS_END,\n                }\n            },\n            // isVaild === false\n            // 这个分支有STATUS_FAILED\n            0: {\n                [STATUS_START]: {\n                    [INPUT_MOVE]: STATUS_CANCELLED,\n                    [INPUT_END]: STATUS_END,\n                    [INPUT_CANCEL]: STATUS_CANCELLED\n                },\n                [STATUS_MOVE]: {\n                    [INPUT_MOVE]: STATUS_CANCELLED,\n                    [INPUT_END]: STATUS_END,\n                    [INPUT_CANCEL]: STATUS_CANCELLED\n                }\n            }\n        };\n        // console.warn(Number(isVaild),activeStatus, STATE_MAP[Number(isVaild)][activeStatus]);\n        if (undefined !== STATE_MAP[Number(isVaild)][activeStatus]) {\n            return STATE_MAP[Number(isVaild)][activeStatus][inputType] || activeStatus;\n        } else {\n            return activeStatus;\n        }\n    };\n\n    /**\n     * 如果识别结束, 那么重置状态\n     */\n    protected _resetStatus() {\n        // if (this.name === 'tap') console.log('@', this.status);\n        //STATUS_RECOGNIZED === STATUS_END\n        if (-1 !== [STATUS_END, STATUS_CANCELLED, STATUS_RECOGNIZED, STATUS_FAILED].indexOf(this.status)) {\n\n            this.status = STATUS_POSSIBLE;\n        };\n    };\n\n    /**\n     * 适用于大部分移动类型的手势, \n     * 如pan/rotate/pinch/swipe\n     * @param {Computed} 计算数据 \n     */\n    recognize(computed: Computed) {\n        // if(this.name === 'pan')    console.log(this.name,this.status);\n        // 是否识别成功\n        let isVaild = this.test(computed);\n\n        // 重置status\n        this._resetStatus();\n\n        // 状态变化流程\n        let { eventType } = computed;\n\n        this.status = this.flow(isVaild, this.status, eventType);\n\n        if (STATUS_CANCELLED === this.status) {\n            this.emit(this.options.name + 'cancel', computed);\n            return;\n        }\n\n        // 是否已识别\n        this.isRecognized = -1 < [STATUS_START, STATUS_MOVE, STATUS_END, STATUS_RECOGNIZED].indexOf(this.status);\n        // 识别后触发的事件\n        if (this.isRecognized) {\n            this.afterRecognized(computed);\n            // computed = this.lockDirection(computed);d\n            this.emit(this.options.name, computed);\n            // console.log(this.options.name, computed);\n            if (-1 < [STATUS_START, STATUS_MOVE, STATUS_END, STATUS_RECOGNIZED].indexOf(this.status)) {\n                // panstart | panmove | panend等\n                this.emit(this.options.name + this.status, computed);\n                this.afterEmit(computed);\n            }\n        }\n    };\n\n    /**\n     * 识别条件, 基于异步\n     * @param {Computed} 计算数据\n     * @param {(isRecognized: boolean) => void}} 接收是否识别状态\n     */\n    abstract test(computed: Computed): boolean;\n\n    /**\n     * 识别成功后执行\n     * 这个阶段可以对computed数据做些处理\n     * 比如pan可以针对不支持的方向吧deltaX/Y调整为0\n     * swipe可以把不支持的方向上的速率调整为0\n     * @param {Computed} 计算数据 \n     */\n    public afterRecognized(computed: Computed): void { };\n\n    /**\n     * 基类的所有emit触发后执行\n     * @param {Computed} computed \n     */\n    public afterEmit(computed: Computed): void { };\n\n    /**\n     * 计算当前手势的touch-action\n     */\n    abstract getTouchAction(): string[];\n};\n\n","import { Computed, Point } from '../interface';\nimport {\n    STATUS_RECOGNIZED,\n    STATUS_FAILED,\n    STATUS_START,\n} from '../const/recognizerStatus';\nconst { setTimeout, clearTimeout } = window;\nimport Recognizer from './Base';\nimport { INPUT_END } from '../const';\nimport { getVLength } from '../vector';\nexport default class TapRecognizer extends Recognizer {\n    public tapCount: number;\n\n\n    // 记录每次单击完成时的坐标\n    public prevTapPoint?: Point;\n    public prevTapTime?: number;\n\n    // 多次tap之间的距离是否满足要求\n    public isValidDistanceFromPrevTap?: boolean;\n\n    // timer\n    private _delayFailTimer?: number;\n    private _waitOtherFailedTimer?: number;\n\n    static DEFAULT_OPTIONS = {\n        name: 'tap',\n        pointLength: 1,\n        tapTimes: 1,\n        // 等待下一次tap的时间, \n        // 超过该事件就立即判断当前点击数量\n        waitNextTapTime: 300,\n        disabled: false,\n        // 从接触到离开允许产生的最大距离\n        positionTolerance: 2,\n        // 2次tap之间允许的最大位移\n        tapsPositionTolerance: 9,\n        // 从接触到离开屏幕的最大时间\n        maxPressTime: 250,\n    };\n    constructor(options = {}) {\n        super(options);\n        this.tapCount = 0;\n    };\n\n    public getTouchAction() {\n        // 单击auto, 多击manipulation=pan + pinch-zoom(禁用了默认双击)\n        return (1 < this.options.tapTimes) ? ['manipulation'] : ['auto'];\n    };\n\n    /**\n     * 判断前后2次点击的距离是否超过阈值\n     * @param {Point} 当前触点\n     * @return {Boolean} 前后2次点击的距离是否超过阈值\n     */\n    private _isValidDistanceFromPrevTap(point: Point): boolean {\n        // 判断2次点击的距离\n        if (undefined !== this.prevTapPoint) {\n            const distanceFromPreviousTap = getVLength({ x: point.x - this.prevTapPoint.x, y: point.y - this.prevTapPoint.y });\n            // 缓存当前点, 作为下次点击的上一点\n            this.prevTapPoint = point;\n            return this.options.tapsPositionTolerance >= distanceFromPreviousTap;\n        } else {\n            this.prevTapPoint = point;\n            return true;\n        }\n    };\n\n    /**\n     * 校验2次tap的时间间隔是否满足\n     * @return {Boolean} 是否满足\n     */\n    private _isValidInterval(): boolean {\n        const now = Date.now();\n        if (undefined === this.prevTapTime) {\n            this.prevTapTime = now;\n            return true;\n        } else {\n            const interval = now - this.prevTapTime;\n            this.prevTapTime = now;\n            return interval < this.options.waitNextTapTime;\n        }\n    };\n\n    /**\n     * 识别后执行\n     * @param {Computed} 计算数据 \n     */\n    public recognize(computed: Computed): void {\n        // 只在end阶段去识别\n        if (INPUT_END !== computed.eventType) return;\n\n        // 如果识别结束, 那么重置状态\n        this._resetStatus();\n\n        // 每一次点击是否符合要求\n        if (this.test(computed)) {\n\n\n            // 一旦每次tap识别成功, 那么一段时间后如果不符合多次点击条件, 设置状态为failed\n            this._cancelDelayFail();\n            this._delayFail();\n\n            // 判断2次点击之间的距离是否过大\n            // 对符合要求的点击进行累加\n            if (this._isValidDistanceFromPrevTap(computed) && this._isValidInterval()) {\n                this.tapCount++;\n            }\n            //  不满足条件, 那么当前的点击作为单击tap触发\n            else {\n                this.tapCount = 1;\n            }\n\n            // 是否满足点击次数要求\n            if (0 === this.tapCount % this.options.tapTimes ) {\n                // 如果符合点击次数的要求\n                // 那么取消延迟失败的定时器\n                this._cancelDelayFail();\n                // 仅仅为了不让状态为possible和failed\n                // 这样isTheOtherFailed才不会错误的触发其他还没有符合条件的tap\n                // 因为isTheOtherFailed方法会监测possible和failed俩种状态\n                // 这里的STATUS_START可以想成在等待failture前的等待状态\n                this.status = STATUS_START;\n                // 如果需要其他手势失败\n                // 等待(300ms)其他手势失败后触发\n                if (this.hasRequireFailure()) {\n                    this._waitOtherFailedTimer = setTimeout(() => {\n                        // 检查指定手势是否识别为Failed\n                        if (this.isTheOtherFailed()) {\n                            this.status = STATUS_RECOGNIZED;\n                            this.emit(this.options.name, { ...computed, tapCount: this.tapCount });\n                        } else {\n                            this.status = STATUS_FAILED;\n                        };\n                        // 不论成功失败都要重置tap计数\n                        this.reset();\n                    }, this.options.waitNextTapTime);\n                }\n                // 如果不需要等待其他手势失败\n                // 那么立即执行\n                else {\n                    this.status = STATUS_RECOGNIZED;\n                    this.emit(this.options.name, { ...computed, tapCount: this.tapCount });\n                    this.reset();\n                }\n            }\n        } else {\n            // if (this.options.tapTimes !== this.tapCount) {\n            //     clearTimeout(this._waitOtherFailedTimer);\n            // }\n            this.reset();\n            this.status = STATUS_FAILED;\n        }\n    };\n\n    public reset() {\n        this.tapCount = 0;\n        this.prevTapPoint = undefined;\n        this.prevTapTime = undefined;\n    };\n\n    /**\n     * 指定时间后, 设置状态为失败\n     */\n    private _delayFail(cb: () => void = () => { }) {\n        this._delayFailTimer = setTimeout(() => {\n            this.status = STATUS_FAILED;\n            cb();\n        }, this.options.waitNextTapTime);\n    };\n\n    /**\n     * 取消延迟失败定时\n     */\n    private _cancelDelayFail() {\n        clearTimeout(this._delayFailTimer);\n    };\n\n    /**\n      * 识别条件\n      * @param {Computed} 计算数据\n      * @return {Boolean} 是否验证成功\n      */\n    public test(computed: Computed): boolean {\n        // 判断是否发生大的位置变化\n        const { distance, deltaTime, maxpointLength } = computed;\n        // 检查\n        // 1. 触点数\n        // 2. 移动距离\n        // 3. start至end的事件, 区分tap和press\n        return maxpointLength === this.options.pointLength &&\n            this.options.positionTolerance >= distance &&\n            this.options.maxPressTime > deltaTime;\n    };\n\n    public afterEmit(computed: Computed): void { }\n};","import { Computed } from '../interface';\nimport {\n    STATUS_POSSIBLE,\n    STATUS_CANCELLED,\n    STATUS_FAILED, STATUS_RECOGNIZED\n} from '../const/recognizerStatus';\nimport { INPUT_CANCEL, INPUT_END, INPUT_MOVE, INPUT_START } from '../const';\nimport Recognizer from './Base';\nexport default class PressRecognizer extends Recognizer {\n    private _timeoutId?: number;\n    static DEFAULT_OPTIONS = {\n        name: 'press',\n        pointLength: 1,\n        threshold: 9,\n        minPressTime: 251,\n        disabled: false\n    };\n    constructor(options = {}) {\n        super(options);\n    };\n\n    getTouchAction(): string[] {\n        return ['auto'];\n    };\n\n    recognize(computed: Computed): void {\n        const { eventType, pointLength, distance, deltaTime } = computed;\n\n        // 1. start阶段\n        // 2. 触点数符合\n        // 那么等待minPressTime时间后触发press\n        if (INPUT_START === eventType && this.isValidPointLength(pointLength)) {\n            // 重置状态\n            this._resetStatus();\n            // 延迟触发\n            this.cancel();\n            this._timeoutId = window.setTimeout(() => {\n                this.status = STATUS_RECOGNIZED;\n                this.emit(this.options.name, computed);\n            }, this.options.minPressTime);\n        }\n\n        // 触发pressup条件:\n        // 1. end阶段\n        // 2. 已识别\n        else if (INPUT_END === eventType && STATUS_RECOGNIZED === this.status) {\n            this.emit(`${this.options.name}up`, computed);\n        }\n\n        // 一旦不满足必要条件, 触发失败\n        // 对应cancel和end阶段\n        else if (!this.test(computed) || (this.options.minPressTime > deltaTime && -1 !== [INPUT_END, INPUT_CANCEL].indexOf(eventType) )) {\n            this.cancel();\n            this.status = STATUS_FAILED;\n        }\n\n    };\n\n    /**\n     * 是否满足:\n     * 移动距离不大\n     */\n    test({ distance}: Computed): boolean {\n        return this.options.threshold > distance;\n    };\n\n    cancel(): void {\n        clearTimeout(this._timeoutId);\n    }\n\n    afterEmit() { }\n};","/**\n * 获取数组中方向是否水平/垂直\n * @param {directionString[]} 方向数组, ['left', 'right','up', 'down']\n * \n */\nimport {directionString} from '../interface';\nexport default (directions: [directionString?, directionString?, directionString?, directionString?]): { hasHorizontal: boolean, hasVertical: boolean } => {\n    let hasHorizontal = false;\n    let hasVertical = false;\n    for (let direction of directions) {\n        if (-1 < ['left', 'right'].indexOf(<string>direction)) {\n            hasHorizontal = true;\n            if (hasVertical) break;\n        } else if (-1 < ['up', 'down'].indexOf(<string>direction)) {\n            hasVertical = true;\n            if (hasHorizontal) break;\n        } else {\n            throw new Error('wrong direction!');\n        }\n    };\n    return { hasHorizontal, hasVertical };\n};","import { Computed, directionString } from '../interface';\nimport { INPUT_MOVE } from '../const';\nimport Recognizer from './Base';\nimport getHV from '../untils/getHV';\n\nexport default class PanRecognizer extends Recognizer {\n    static DEFAULT_OPTIONS = {\n        name: 'pan',\n        threshold: 10,\n        pointLength: 1,\n        directions: ['up', 'right', 'down', 'left']\n    };\n    constructor(options = {}) {\n        super(options);\n    };\n\n    getTouchAction() {\n        let touchActions = ['auto'];\n        let { hasHorizontal, hasVertical } = getHV(this.options.directions);\n        if (hasHorizontal && hasVertical) {\n            touchActions = ['none'];\n        } else if (!hasHorizontal && hasVertical) {\n            // 没有水平移动\n            touchActions = ['pan-x'];\n        } else if (!hasVertical && hasHorizontal) {\n            // 没有垂直移动\n            touchActions = ['pan-y'];\n        }\n        return touchActions;\n    };\n\n    /**\n     * @param {Computed} 计算数据\n     * @return {Boolean}} .是否是当前手势 \n     */\n    test({ distance, direction, eventType, pointLength }: Computed): boolean {\n        return INPUT_MOVE === eventType &&\n            (this.isRecognized || this.options.threshold < distance) &&\n            this.isValidPointLength(pointLength) &&\n            this.isVaildDirection(direction);\n    };\n\n    /**\n     * 识别后发布panleft等事件\n     * @param {Computed} 计算数据\n     */\n    afterEmit(computed: Computed) {\n        if ('none' !== computed.direction) {\n            this.emit(this.options.name + computed.direction, computed);\n        }\n    };\n\n    afterRecognized(computed: Computed) {\n        this.lockDirection(computed);\n    }\n\n    /**\n     * 移除限制方向的deltaX/Y\n     * @param {Computed} computed \n     */\n    public lockDirection(computed: Computed): Computed {\n        if (undefined === this.options.directions || 0 === this.options.directions.length) return computed;\n        let deltaX = 0;\n        let deltaY = 0;\n        this.options.directions.forEach((direction: string) => {\n            if ('left' === direction && 0 > computed.deltaX) {\n                deltaX = computed.deltaX;\n            } else if ('right' === direction && 0 < computed.deltaX) {\n                deltaX = computed.deltaX;\n            } else if ('down' === direction && 0 < computed.deltaY) {\n                deltaY = computed.deltaY;\n            } else if ('up' === direction && 0 > computed.deltaY) {\n                deltaY = computed.deltaY;\n            }\n        });\n        computed.deltaX = deltaX;\n        computed.deltaY = deltaY;\n        return computed;\n    };\n};","import Recognizer from './Base';\nimport { Computed } from '../interface';\nimport { INPUT_END } from '../const';\nexport default class SwipeRecognizer extends Recognizer {\n    static DEFAULT_OPTIONS = {\n        name: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        pointLength: 1,\n        directions: ['up', 'right', 'down', 'left']\n    };\n    constructor(options = {}) {\n        super(options);\n    };\n\n    getTouchAction() {\n        return ['none'];\n    };\n\n    /**\n     * 识别后发布swipeleft等事件\n     * @param {Computed} 计算数据\n     */\n    afterEmit(computed: Computed) {\n        if ('none' !== computed.direction) {\n            this.emit(this.options.name + computed.direction, computed);\n        }\n    };\n\n    /**\n     * 识别条件\n     * @param {Computed} 计算数据\n     */\n    test(computed: Computed): boolean {\n        if (INPUT_END !== computed.eventType) return false;\n\n        // 非end阶段, 开始校验数据\n        const { direction, velocityX, velocityY, maxpointLength, distance } = computed;\n        // 如果只支持水平或垂直, 那么其他方向速率为0;\n        // 有效速率\n        let vaildVelocityX: number = velocityX;\n        let vaildVelocityY: number = velocityY;\n        if (this.isOnlyHorizontal()) {\n            vaildVelocityY = 0;\n        } else if (this.isOnlyVertical()) {\n            vaildVelocityX = 0;\n        }\n\n        let vaildVelocity = Math.sqrt(vaildVelocityX * vaildVelocityX + vaildVelocityY * vaildVelocityY)\n\n        return 1 === maxpointLength &&\n            this.options.threshold < distance &&\n            this.isVaildDirection(direction) &&\n            this.options.velocity < vaildVelocity;\n    };\n};","import { Computed } from '../interface';\nimport Recognizer from './Base';\n\n\nexport default class PinchRecognizer extends Recognizer {\n    private _prevScale: number;\n    static DEFAULT_OPTIONS = {\n        name: 'pinch',\n        // 触发事件所需要的最小缩放比例\n        threshold: 0,\n        pointLength: 2,\n    };\n    constructor(options={}) {\n        super(options);\n        this._prevScale = 1;\n    };\n    \n    getTouchAction(){\n        return ['none'];\n    };\n\n    afterEmit(computed: Computed) {\n        if('end' === computed.eventType) return;\n        // pinchin | pinchout\n        const { scale } = computed;\n        if (1 !== scale) {\n            const inOrOut = scale > this._prevScale ? 'out' : 'in';\n            this.emit(this.options.name + inOrOut, computed);\n        }\n        this._prevScale = scale;\n    };\n\n    /**\n     * 识别条件\n     * @param {Computed} 计算数据\n     * @param {(isRecognized: boolean) => void}} 接收是否识别状态\n     */\n    test({ pointLength, scale }: Computed): boolean {\n        // 如果触碰点数要大于指定\n        // 如果缩放超过阈值, 或者已识别\n        // console.log({scale})\n        return this.isValidPointLength(pointLength) && (this.options.threshold < Math.abs(scale-1) || this.isRecognized);\n    };\n};","import Base from './Base';\nimport { Computed } from '../interface';\nexport default class RotateRecognizer extends Base {\n    static DEFAULT_OPTIONS = {\n        name: 'rotate',\n        // 触发事件所需要的最小角度\n        threshold: 0,\n        pointLength: 2,\n    };\n    constructor(options = {}) {\n        super(options);\n    };\n\n    getTouchAction() {\n        return ['none'];\n    };\n\n    /**\n     * 无特殊事件要触发\n     */\n    afterEmit(computed: Computed) { };\n\n    /**\n     * 识别条件\n     * @param {Computed} 计算数据\n     * @return {Boolean} 接收是否识别状态\n     */\n    test({ pointLength, angle }: Computed): boolean {\n        // 如果触碰点数要大于指定\n        // 如果缩放超过阈值, 或者已识别\n        return this.isValidPointLength(pointLength) && (this.options.threshold < Math.abs(angle) || this.isRecognized);\n    };\n};","/**\n * ==================== 参考 ====================\n * https://segmentfault.com/a/1190000010511484#articleHeader0\n * https://segmentfault.com/a/1190000007448808#articleHeader1\n * hammer.js\n * \n * ==================== 支持的手势 ====================\n * rotate 旋转\n * pinch 捏合,\n * tap 单机\n * doubleTap 双击\n * press 按压\n * pan 拖拽\n * swipe 快划\n * \n * ==================== 流程 ====================\n * 格式化Event成统一的pointer格式 => 通过pointer数据计算 => 用计算结果去识别手势\n */\nimport AnyEvent from 'any-event';\nimport { Computed } from './interface';\nimport { SUPPORT_TOUCH } from './const'; ``\nimport inputManage from './inputManage';\nimport compute from './compute/index';\nimport computeTouchAction from './untils/computeTouchAction'\n// 识别器\nimport Tap from './recognitions/Tap';\nimport Press from './recognitions/Press';\nimport Pan from './recognitions/Pan';\nimport Swipe from './recognitions/Swipe';\nimport Pinch from './recognitions/Pinch';\nimport Rotate from './recognitions/Rotate';\nimport * as Vector from './vector';\ninterface Options {\n    touchAction?: 'compute' | 'auto' | 'manipulation' | 'pan-x' | 'pan-y' | 'none';\n    hasDomEvents?: boolean;\n    isPreventDefault?: boolean;\n    style?: { [key: string]: string };\n};\nexport default class AnyTouch {\n    // 识别器\n    static Tap = Tap;\n    static Press = Press;\n    static Pan = Pan;\n    static Swipe = Swipe;\n    static Pinch = Pinch;\n    static Rotate = Rotate;\n\n    // 向量计算\n    static Vector = Vector;\n\n    // mini的事件触发器\n    static EventEmitter = AnyEvent;\n\n    // 目标元素\n    el: HTMLElement;\n\n    default: Options;\n\n    inputType: string;\n\n    recognizers: { [propName: string]: any, name: string }[];\n\n    options: Options;\n\n    version: string;\n\n    eventEmitter: any;\n\n    // 是否阻止后面的识别器运行\n    private _isStopped: boolean;\n\n    /**\n     * @param {Element} 目标元素\n     * @param {Object} 选项\n     */\n    constructor(el: HTMLElement, options?: Options) {\n        this.version = '__VERSION__';\n        this.default = {\n            touchAction: 'compute',\n            hasDomEvents: true,\n            isPreventDefault: false,\n            style: {\n                // 禁用选择文字\n                '-moz-user-select': 'none',\n                ' -webkit-user-select': 'none',\n                '-ms-user-select': 'none',\n                'user-select': 'none',\n                // https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-touch-select\n                // 禁用选择文字, 在winphone下\n                '-ms-touch-select': 'none',\n                // 点击元素的高亮颜色配置\n                '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\n                ' -webkit-user-drag': 'none',\n                // 当你触摸并按住触摸目标时候，\n                // 禁止或显示系统默认菜单。\n                // 在iOS上，当你触摸并按住触摸的目标，\n                // 比如一个链接，Safari浏览器将显示链接有关的系统默认菜单。\n                // 这个属性可以让你禁用系统默认菜单。\n                '-webkit-touch-callout': 'none'\n            }\n        };\n        this.el = el;\n        this.inputType = SUPPORT_TOUCH ? 'touch' : 'mouse';\n        this.options = { ...this.default, ...options };\n        // eventEmitter\n        this.eventEmitter = new AnyEvent();\n        this._isStopped = false;\n        // 识别器\n        // 注入当前方法和属性, 方便在识别器中调用类上的方法和属性\n        this.recognizers = [\n            new Rotate().$injectRoot(this),\n            new Pinch().$injectRoot(this),\n            new Pan().$injectRoot(this),\n            new Swipe().$injectRoot(this),\n            new Tap().$injectRoot(this),\n            new Press().$injectRoot(this),\n        ];\n        // 应用设置\n        this.update();\n\n        // 绑定事件\n        this.unbind = this._bindRecognizers(this.el).unbind;\n    };\n\n\n    /**\n     * 计算touch-action\n     * @param {HTMLElement} 目标元素 \n     */\n    private _updateTouchAction() {\n        if ('compute' === this.options.touchAction) {\n            let touchActions = [];\n            for (let recognizer of this.recognizers) {\n                touchActions.push(...recognizer.getTouchAction());\n            };\n            this.el.style.touchAction = computeTouchAction(touchActions);\n        } else {\n            this.el.style.touchAction = this.options.touchAction || 'auto';\n        }\n    };\n\n    /**\n     * 应用几个提高体验的样式\n     * 如: 禁止选择文字/透明点击高亮颜色等\n     */\n    private _updateStyle() {\n        for (let key in this.options.style) {\n            let value = this.options.style[key];\n            (this.el.style as any)[key] = value;\n        }\n    };\n\n    /**\n     * 更新设置\n     */\n    public update() {\n        this._updateStyle();\n        this._updateTouchAction();\n    };\n\n    /**\n     * 绑定手势到指定元素\n     * 暂时只支持事件冒泡阶段触发, \n     * 改为捕获阶段需要对inputListener进行编号, \n     * 产生大量事件绑定,\n     * 而非在一次触发事件中执行所有手势判断\n     * @param {Element} 待绑定手势元素\n     */\n    private _bindRecognizers(el: Element) {\n        const boundInputListener = this.inputListener.bind(this);\n        // Touch\n        if ('touch' === this.inputType) {\n            const events = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n            events.forEach(eventName => {\n                el.addEventListener(eventName, boundInputListener);\n            });\n            return {\n                unbind: () => {\n                    events.forEach(eventName => {\n                        el.removeEventListener(eventName, boundInputListener);\n                    });\n                }\n            }\n\n\n        }\n        // Mouse\n        else {\n            el.addEventListener('mousedown', boundInputListener);\n            window.addEventListener('mousemove', boundInputListener);\n            window.addEventListener('mouseup', boundInputListener);\n            return {\n                unbind: () => {\n                    el.removeEventListener('mousedown', boundInputListener);\n                    window.removeEventListener('mousemove', boundInputListener);\n                    window.removeEventListener('mouseup', boundInputListener);\n                }\n            };\n        }\n    };\n\n    /**\n     * 添加识别器\n     * @param recognizer 识别器\n     */\n    add(recognizer: any): void {\n        recognizer.$injectRoot(this);\n        const hasSameName = this.recognizers.some((theRecognizer: any) => recognizer.name === theRecognizer.name);\n        if (hasSameName) {\n            this.eventEmitter.emit('error', { code: 1, message: `${recognizer.name}识别器已经存在!` })\n        } else {\n            this.recognizers.push(recognizer);\n            this.update();\n        }\n    };\n\n    /**\n     * 获取识别器通过名字\n     * @param {String} 识别器的名字\n     * @return {Recognizer} 返回识别器\n     */\n    get(name: string): any {\n        return this.recognizers.find(recognizer => name === recognizer.options.name);\n    };\n\n    /**\n     * 设置\n     * @param {Options} 选项 \n     */\n    set(options: Options): void {\n        this.options = { ...this.default, ...options };\n        this.update();\n    };\n\n    /**\n     * 停止识别\n     */\n    stop() {\n        this._isStopped = true;\n    }\n\n    /**\n     * 删除识别器\n     * @param {String} 识别器name\n     */\n    remove(recognizerName: string): void {\n        for (let [index, recognizer] of this.recognizers.entries()) {\n            if (recognizerName === recognizer.options.name) {\n                this.recognizers.splice(index, 1);\n                break;\n            }\n        }\n    };\n\n    /**\n     * 监听input变化\n     * @param {Event}\n     */\n    inputListener(event: Event): void {\n        if (this.options.isPreventDefault) {\n            event.preventDefault();\n        }\n\n        if (!event.cancelable) {\n            this.eventEmitter.emit('error', { code: 0, message: '页面滚动的时候, 请暂时不要操作元素!' });\n        }\n\n        // 管理历史input\n        let inputs = inputManage(event);\n\n        // 当是鼠标事件的时候, mouseup阶段的input为undefined\n        if (undefined !== inputs) {\n            const computed = compute(inputs);\n            // 重置停止标记\n            if (computed.isFirst) {\n                this._isStopped = false;\n            }\n            // input事件\n            this.emit('input', computed);\n            if (computed.isFirst) {\n                this.emit('inputstart', computed);\n            } else if (computed.isFinal) {\n                if ('cancel' === computed.eventType) {\n                    this.emit('inputcancel', computed);\n                } else {\n                    this.emit('inputend', computed);\n                }\n            } else {\n                if (inputs.prevInput.pointLength > inputs.input.pointLength) {\n                    this.emit('inputreduce', computed);\n                } else if (inputs.prevInput.pointLength < inputs.input.pointLength) {\n\n                    this.emit('inputadd', computed);\n                } else {\n                    this.emit('inputmove', computed);\n                }\n            };\n\n\n            for (let recognizer of this.recognizers) {\n                if (recognizer.disabled) continue;\n                // 如果遇到停止标记, 立即停止运行后面的识别器\n                recognizer.recognize(computed);\n                if (this._isStopped) {\n                    break;\n                }\n            }\n        }\n    };\n\n    /**\n     * 注册事件\n     * @param {String} 事件名\n     * @param {Function} 回调函数\n     */\n    on(type: string, listener: (event: Computed) => void, options: { [k: string]: boolean } | boolean = false): void {\n        this.eventEmitter.on(type, listener);\n    };\n\n    /**\n     * 解绑事件\n     * @param {String} 事件名 \n     * @param {Function} 事件回调\n     */\n    off(type: string, listener?: (event: Computed) => void): void {\n        this.eventEmitter.off(type, listener);\n    };\n\n    /**\n     * 触发事件, 同时type会作为payload的一个键值\n     * @param {String} 类型名\n     * @param {Object} 数据\n     */\n    emit(type: string, payload: any) {\n        payload.type = type;\n        this.eventEmitter.emit(type, payload);\n    };\n\n    /**\n     * 解绑所有触摸事件\n     */\n    public unbind(): void { };\n\n    /**\n     * 销毁\n     */\n    destroy() {\n        // 解绑事件\n        this.unbind();\n        this.eventEmitter.destroy();\n    };\n};"],"names":["__values","__read","__spread","tslib_1.__values","clearTimeout","tslib_1.__extends","Base","AnyEvent","Rotate","Pinch","Pan","Swipe","Tap","Press"],"mappings":"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"}