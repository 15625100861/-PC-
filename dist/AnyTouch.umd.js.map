{"version":3,"file":"AnyTouch.umd.js","sources":["../node_modules/_any-event@0.3.6@any-event/dist/AnyEvent.es.js","../src/const.ts","../src/vector.ts","../src/input/adapters/Touch.ts","../src/input/adapters/Mouse.ts","../src/input/InputFactory.ts","../src/InputManage.ts","../src/$_cache.ts","../src/compute/intervalCompute.ts","../src/compute/computeDistance.ts","../src/compute/computeDeltaXY.ts","../src/compute/computeMaxLength.ts","../src/compute/computeVector.ts","../src/compute/computeScale.ts","../src/compute/computeAngle.ts","../src/compute/computeMulti.ts","../src/compute/index.ts","../src/untils/computeTouchAction.ts","../src/const/recognizerStatus.ts","../src/recognitions/Base.ts","../src/recognitions/Tap.ts","../src/recognitions/Press.ts","../src/untils/getHV.ts","../src/recognitions/Pan.ts","../src/recognitions/Swipe.ts","../src/recognitions/Pinch.ts","../src/recognitions/Rotate.ts","../src/AnyTouch.ts","../src/vueDirective/InstanceManage.ts","../src/vueDirective/index.ts","../src/main.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        this._listenersMap = {};\n    }\n    EventEmitter.prototype.on = function (eventName, listener) {\n        if (undefined === this._listenersMap[eventName]) {\n            this._listenersMap[eventName] = [];\n        }\n        this._listenersMap[eventName].push(listener);\n        return this;\n    };\n    EventEmitter.prototype.once = function (eventName, listener) {\n        listener.isOnce = true;\n        this.on(eventName, listener);\n        return this;\n    };\n    EventEmitter.prototype.off = function (eventName, listener) {\n        var listeners = this._listenersMap[eventName];\n        if (undefined !== listeners) {\n            if (undefined === listener) {\n                delete this._listenersMap[eventName];\n            }\n            else {\n                var index = listeners.findIndex(function (fn) { return fn === listener; });\n                listeners.splice(index, 1);\n            }\n        }\n        return this;\n    };\n    EventEmitter.prototype.emit = function (eventName) {\n        var payload = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            payload[_i - 1] = arguments[_i];\n        }\n        var e_1, _a;\n        var listeners = this._listenersMap[eventName];\n        if (undefined !== listeners && 0 < listeners.length) {\n            try {\n                for (var _b = __values(listeners.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var _d = __read(_c.value, 2), index = _d[0], listener = _d[1];\n                    if (listener.isOnce) {\n                        var listenerClone = listener;\n                        listeners.splice(index, 1);\n                        listenerClone.apply(void 0, __spread(payload));\n                    }\n                    else {\n                        listener.apply(void 0, __spread(payload));\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b[\"return\"])) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    EventEmitter.prototype.has = function (eventName) {\n        return undefined !== this._listenersMap[eventName] && 0 < this._listenersMap[eventName].length;\n    };\n    EventEmitter.prototype.getEventNames = function () {\n        var eventNames = [];\n        for (var eventName in this._listenersMap) {\n            eventNames.push(eventName);\n        }\n        return eventNames;\n    };\n    EventEmitter.prototype.eventNames = function () {\n        return this.getEventNames();\n    };\n    EventEmitter.prototype.destroy = function () {\n        this._listenersMap = {};\n    };\n    return EventEmitter;\n}());\n\nexport default EventEmitter;\n","// 简单判断是否手机设备\r\nexport const MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n// console.log('ua', navigator.userAgent);\r\n// 是否手机设备\r\nexport const IS_MOBILE = MOBILE_REGEX.test(navigator.userAgent);\r\n\r\n// 是否支持touch事件\r\nexport const SUPPORT_TOUCH = ('ontouchstart' in window);\r\n// 是否是移动设备\r\nexport const SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\n// 方向\r\nexport const DIRECTION_NONE = 1; // 0000 0001\r\nexport const DIRECTION_LEFT = 2; //  0000 0010\r\nexport const DIRECTION_RIGHT = 4; // 0000 0100 \r\nexport const DIRECTION_UP = 8; // 0000 1000\r\nexport const DIRECTION_DOWN = 16; // 0001 0000\r\n\r\n// 位运算 求值 对上上面的4个方向可以简单理解为\"+\"\r\nexport const DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT; // 6\r\nexport const DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN; // 24\r\nexport const DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL; // 30\r\n\r\n// 计算触发时间间隔, 防止事件触发就一直计算\r\nexport const COMPUTE_INTERVAL = 16;\r\n\r\n\r\n// 计算时候取touchs.clientX | clientY\r\nexport const CLIENT_X = 'clientX';\r\nexport const CLIENT_Y = 'clientY';\r\n\r\n\r\n// 识别器状态码\r\nexport const RECOGNIZER_STATUS_POSSIBLE = 1;\r\nexport const RECOGNIZER_STATUS_BEGAN = 2;\r\nexport const RECOGNIZER_STATUS_CHANGED = 4;\r\nexport const RECOGNIZER_STATUS_ENDED = 8;\r\nexport const RECOGNIZER_STATUS_RECOGNIZED = RECOGNIZER_STATUS_ENDED;\r\nexport const RECOGNIZER_STATUS_CANCELLED = 16;\r\nexport const RECOGNIZER_STATUS_FAILED = 32;\r\n\r\n// input的类型\r\nexport const INPUT_START = 'start';\r\nexport const INPUT_MOVE = 'move';\r\nexport const INPUT_CANCEL = 'cancel';\r\nexport const INPUT_END = 'end';\r\n","import { CLIENT_X, CLIENT_Y } from './const';\r\nimport { directionString, Point } from './interface';\r\ntype Vector = Point;\r\n\r\n/**\r\n * 获取向量长度(向量模)\r\n * @param {Object} 向 量\r\n */\r\nexport const getVLength = (v: Vector): number => {\r\n    return Math.sqrt(v.x * v.x + v.y * v.y);\r\n}\r\n\r\n/**\r\n * 点积\r\n * @param {Object} v1\r\n * @param {Object} v2\r\n */\r\nexport const getDotProduct = (v1: Vector, v2: Vector) => {\r\n    return v1.x * v2.x + v1.y * v2.y;\r\n}\r\n\r\n/**\r\n * 向量夹角(弧度)\r\n * @param {Object} v1\r\n * @param {Object} v2\r\n */\r\nexport const getRadian = (v1: Vector, v2: Vector) => {\r\n    var mr = getVLength(v1) * getVLength(v2);\r\n    if (mr === 0) return 0;\r\n    var r = getDotProduct(v1, v2) / mr;\r\n    if (r > 1) r = 1;\r\n    return Math.acos(r);\r\n}\r\n\r\n/**\r\n * 求旋转方向\r\n * 顺时针/逆时针\r\n */\r\nexport const getCross = (v1: Vector, v2: Vector) => {\r\n    return v1.x * v2.y - v2.x * v1.y;\r\n}\r\n\r\n/**\r\n * 向量夹角(角度)\r\n * @param {Object} v1\r\n * @param {Object} v2\r\n */\r\nexport const getAngle = (v1: Vector, v2: Vector) => {\r\n    var angle = getRadian(v1, v2);\r\n    if (getCross(v1, v2) > 0) {\r\n        angle *= -1;\r\n    }\r\n    return radianToAngle(angle);\r\n};\r\n\r\n/**\r\n * 弧度转角度\r\n * @param {Number} 弧度 \r\n */\r\nexport const radianToAngle = (radian: number): number => radian / Math.PI * 180;\r\n\r\n/**\r\n * 角度转弧度\r\n * @param {Number} 角度 \r\n */\r\nexport const angleToRadian = (angle: number): number => angle / 180 * Math.PI;\r\n\r\n/**\r\n * 获取多点之间的中心坐标\r\n * @param {Array} 触碰点 s\r\n */\r\nexport const getCenter = (points: { clientX: number, clientY: number }[]): Point => {\r\n    const { length } = points;\r\n    // 由于是触碰后才运行getCenter, 所以一定至少有一个点(end阶段也有clientX/Y)\r\n    // 所以不做 0 < length 的判断了\r\n    const countPoint = points.reduce((countPoint: Point, point: any) => {\r\n        countPoint.x += point[CLIENT_X];\r\n        countPoint.y += point[CLIENT_Y];\r\n        return countPoint;\r\n    }, { x: 0, y: 0 });\r\n    return { x: Math.round(countPoint.x / length), y: Math.round(countPoint.y / length) }\r\n};\r\n\r\n/**\r\n * \r\n * @param {Number} 事件开始到结束的X位移 \r\n* @param {Number} 事件开始到结束的Y位移 \r\n */\r\nexport const getDirection = (x: number, y: number): directionString => {\r\n    if (x === y) {\r\n        return 'none';\r\n    } else if (Math.abs(x) > Math.abs(y)) {\r\n        return 0 < x ? 'right' : 'left';\r\n    } else {\r\n        return 0 < y ? 'down' : 'up';\r\n    }\r\n};\r\n","import { BaseInput, eventType } from '../../interface';\r\nexport default class {\r\n    load(event: TouchEvent): BaseInput {\r\n        const points = Array.from(event.touches).map(({ clientX, clientY }) => ({ clientX, clientY }));\r\n        const changedPoints = Array.from(event.changedTouches).map(({ clientX, clientY }) => ({ clientX, clientY }));\r\n        return {\r\n            eventType: <eventType>event.type.replace('touch', ''),\r\n            changedPoints,\r\n            points,\r\n            nativeEvent: event\r\n        };\r\n    }\r\n}; ","import { BaseInput, eventType } from '../../interface';\r\n\r\n// 默认MouseEvent中对type声明仅为string\r\nexport default class {\r\n    prevPoints?: { clientX: number, clientY: number }[];\r\n    isPressed: boolean;\r\n    constructor() {\r\n        this.isPressed = false;\r\n    };\r\n\r\n    load(event: MouseEvent): BaseInput | void {\r\n        let { clientX, clientY, type, button } = event;\r\n\r\n        // changedPoints = prevPoints其实并不能完全等于touch下的changedPoints\r\n        // 但是由于鼠标没有多点输入的需求, \r\n        // 所以暂时如此实现\r\n        const changedPoints = this.prevPoints || [{ clientX, clientY }];\r\n\r\n        let points = [{ clientX, clientY }];\r\n        this.prevPoints = [{ clientX, clientY }];\r\n\r\n        // 必须左键\r\n        if ('mousedown' === type) {\r\n            if (0 === button) {\r\n                this.isPressed = true;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if ('mousemove' === type) {\r\n            if (!this.isPressed) return;\r\n            // 确保移动过程中, 一直按住的都是左键,\r\n            // if(1 !== event.which) {\r\n            //     type = 'mouseup'\r\n            // }\r\n        } else if ('mouseup' === type) {\r\n            if (this.isPressed) {\r\n                points = [];\r\n            } else {\r\n                return;\r\n            };\r\n            this.isPressed = false;\r\n        }\r\n\r\n        const MAP = {\r\n            mousedown: 'start',\r\n            mousemove: 'move',\r\n            mouseup: 'end'\r\n        };\r\n\r\n        return {\r\n            eventType: <eventType>MAP[<'mousedown' | 'mousemove' | 'mouseup'>type],\r\n            changedPoints,\r\n            points,\r\n            nativeEvent: event\r\n        };\r\n    }\r\n}; ","/**\r\n * 构造统一的Input格式\r\n */\r\nimport { Input, Point } from '../interface';\r\nimport { SUPPORT_TOUCH, INPUT_END, INPUT_START, INPUT_CANCEL } from '../const';\r\nimport { getCenter } from '../vector';\r\nimport Touch from './adapters/Touch';\r\nimport Mouse from './adapters/Mouse';\r\n\r\nexport default class {\r\n    // 缓存触点中心\r\n    private _center?: Point;\r\n    public adapter: any;\r\n    constructor() {\r\n        this.adapter = SUPPORT_TOUCH ? new Touch() : new Mouse();\r\n    };\r\n\r\n    public load(event: Event): Input | void {\r\n        // 通过TouchEvent|MouseEvent获取的直接数据\r\n        let baseInput = this.adapter.load(event);\r\n        if (undefined === baseInput) {\r\n            return;\r\n        }\r\n        const { eventType, points, changedPoints } = baseInput;\r\n        // 当前触点数\r\n        const pointLength: number = points.length;\r\n\r\n        // 变化前触点数\r\n        const changedPointLength: number = changedPoints.length;\r\n        // 识别流程的开始和结束标记\r\n        const isFirst = (INPUT_START === eventType) && (0 === changedPointLength - pointLength);\r\n        // 所有触点都离开算作\"final\", 这和hammer.js不一样\r\n        const isFinal = (INPUT_END === eventType || INPUT_CANCEL === eventType) && (0 === pointLength);\r\n\r\n        // 中心坐标\r\n        if (0 < pointLength) {\r\n            this._center = getCenter(baseInput.points);\r\n        }\r\n\r\n        // 当前时间\r\n        const timestamp = Date.now();\r\n\r\n        // 原生属性/方法\r\n        const { target, currentTarget } = event;\r\n        const { x, y } = <Point>(this._center || {});\r\n        return {\r\n            ...baseInput,\r\n            preventDefault: () => {\r\n                event.preventDefault();\r\n            },\r\n            isFirst,\r\n            isFinal,\r\n            pointLength,\r\n            changedPointLength,\r\n            center: this._center,\r\n            x, y,\r\n            timestamp,\r\n            target,\r\n            currentTarget,\r\n            nativeEvent: event\r\n        };\r\n    };\r\n}","import { Input } from './interface';\r\nimport InputFactory from './input/InputFactory';\r\nexport default class {\r\n    // 起点(单点|多点)\r\n    startInput?: Input;\r\n    // 前一次的触电\r\n    prevInput?: Input;\r\n    // 当前触点\r\n    activeInput?: Input;\r\n    // 多点触碰的起点\r\n    startMultiInput?: Input;\r\n\r\n    inputFactory: InputFactory;\r\n\r\n    constructor() {\r\n        this.inputFactory = new InputFactory();\r\n    };\r\n\r\n    load(event: Event): {\r\n        startInput?: Input,\r\n        prevInput?: Input,\r\n        input?: Input,\r\n        startMultiInput?: Input\r\n    } | void {\r\n        // 格式化不同设备输入数据\r\n        const input = this.inputFactory.load(event);\r\n\r\n        // 无效的输入    \r\n        if (undefined === input) return;\r\n\r\n        // 当前输入状态\r\n        const { eventType } = input;\r\n\r\n        // [Start]\r\n        if ('start' === eventType) {\r\n            // 上一步的触点\r\n            // prevInput = undefined;\r\n            // 当前点\r\n            this.activeInput = input;\r\n            // 起点(单点|多点)\r\n            this.startInput = input;\r\n            // 起点(多点)\r\n            if (1 < input.pointLength) {\r\n                this.startMultiInput = input;\r\n            } else {\r\n                // 如果出现了单点, 那么之前的多点起点记录失效\r\n                this.startMultiInput = undefined;\r\n            }\r\n        } else if ('move' === eventType) {\r\n            // 读取上一点\r\n            this.prevInput = this.activeInput;\r\n            this.activeInput = input;\r\n        } else if ('end' === eventType) {\r\n            this.prevInput = this.activeInput;\r\n            this.activeInput = input;\r\n            // console.log(this.startInput, this.el.id);\r\n        }\r\n        return {\r\n            startMultiInput: this.startMultiInput,\r\n            startInput: this.startInput,\r\n            prevInput: this.prevInput,\r\n            input\r\n        };\r\n    };\r\n}; ","class _Cache {\r\n    private _cache: { [k: string]: any };\r\n\r\n    constructor() {\r\n        this._cache = {};\r\n    }\r\n\r\n    set(object:object){\r\n        this._cache = {...this._cache, ...object};\r\n    };\r\n\r\n    get<T>(key: string,defaultValue?:T):T{\r\n        return this._cache[key] || defaultValue;\r\n    };\r\n\r\n    reset() {\r\n        this._cache = {};\r\n    }\r\n}\r\n\r\nexport default new _Cache();\r\n\r\n","// 返回最近一个时间段的计算结果\r\n// 默认间隔25ms做一次计算, 让数据更新,\r\n// 让end阶段读取上一步的计算数据, 比如方向, 速率等...\r\n// 防止快速滑动到慢速滑动的手势识别成swipe\r\nimport { Input,directionString } from '../interface';\r\nimport { COMPUTE_INTERVAL, INPUT_CANCEL, INPUT_END } from '../const';\r\nimport { getDirection } from '../vector';\r\nimport cache from '../$_cache';\r\n\r\nexport default ({ prevInput, input }: { prevInput?: Input, input?: Input }): { speedX: number, speedY: number, velocityX: number, velocityY: number, direction?: directionString } => {\r\n\r\n    // 速率\r\n    let velocityX = 0;\r\n    let velocityY = 0;\r\n\r\n    // 速度\r\n    let speedX = 0;\r\n    let speedY = 0;\r\n\r\n    // 方向\r\n    let direction: directionString = 'none';\r\n\r\n    // 点击鼠标左键, 会出现undefined\r\n    if (undefined !== input) {\r\n        // _prevInput || input用来保证deltaX等不会有undefined参与计算\r\n        const _prevInput = prevInput || input;\r\n        const deltaTime = input.timestamp - _prevInput.timestamp;\r\n        // 每16ms刷新速度数据\r\n        if (-1 === [INPUT_CANCEL, INPUT_END].indexOf(input.eventType) && (COMPUTE_INTERVAL < deltaTime || undefined === cache.get('direction'))) {\r\n            const deltaX = input.x - _prevInput.x;\r\n            const deltaY = input.y - _prevInput.y;\r\n            speedX = Math.round(deltaX / deltaTime * 100) / 100;\r\n            speedY = Math.round(deltaY / deltaTime * 100) / 100;\r\n            velocityX = Math.abs(speedX);\r\n            velocityY = Math.abs(speedY);\r\n            direction = getDirection(deltaX, deltaY) || <directionString>(cache.get('direction'));\r\n            // 存储状态\r\n            cache.set({ speedX });\r\n            cache.set({ speedY });\r\n            cache.set({ velocityX });\r\n            cache.set({ velocityY });\r\n            cache.set({ direction });\r\n        } else {\r\n            speedX = cache.get('speedX', 0);\r\n            speedY = cache.get('speedY', 0);\r\n            velocityX = cache.get('velocityX', 0);\r\n            velocityY = cache.get('velocityY', 0);\r\n            direction = cache.get('direction');\r\n        }\r\n    }\r\n\r\n    return { velocityX, velocityY, speedX, speedY, direction };\r\n};","\r\nimport { Input,directionString } from '../interface';\r\nimport cache from '../$_cache';\r\nimport { CLIENT_X, CLIENT_Y } from '../const';\r\nimport { getVLength, getDirection } from '../vector';\r\nexport default function ({\r\n    startInput,\r\n    input\r\n}: {\r\n    startInput: Input,\r\n    input: Input\r\n}): { displacementX: number, displacementY: number, distanceX: number, distanceY: number, distance: number, overallDirection: directionString } {\r\n    const { eventType } = input;\r\n    let displacementX = 0;\r\n    let displacementY = 0;\r\n    if ('start' === eventType) {\r\n        cache.set({ displacementX });\r\n        cache.set({ displacementY });\r\n    } else if ('move' === eventType) {\r\n        displacementX = Math.round(input!.points[0][CLIENT_X] - startInput!.points[0][CLIENT_X]);\r\n        displacementY = Math.round(input!.points[0][CLIENT_Y] - startInput!.points[0][CLIENT_Y]);\r\n        // 记录本次位移\r\n        cache.set({ displacementX });\r\n        cache.set({ displacementY });\r\n    } else if ('end' === eventType) {\r\n        displacementX = cache.get('displacementX', 0);\r\n        displacementY = cache.get('displacementY', 0);\r\n    }\r\n\r\n    const distanceX = Math.abs(displacementX);\r\n    const distanceY = Math.abs(displacementY);\r\n    const distance = Math.round(getVLength({ x: distanceX, y: distanceY }));\r\n    const overallDirection = getDirection(displacementX, displacementY);\r\n    return {\r\n        displacementX, displacementY, distanceX, distanceY, distance, overallDirection\r\n    };\r\n};","import { radianToAngle } from '../vector';\r\nimport cache from '../$_cache';\r\n\r\nexport default function ({\r\n    prevInput,\r\n    input\r\n}: any): { deltaX: number, deltaY: number, deltaXYAngle: number } {\r\n    // 每次事件触发时位移的变化\r\n    let deltaX: number;\r\n    let deltaY: number;\r\n    // deltaX/Y与2者合位移的角度\r\n    let deltaXYAngle: number = 0;\r\n\r\n    // 计算deltaX/Y\r\n    if ('end' === input.eventType || 'start' === input.eventType) {\r\n        deltaX = 0;\r\n        deltaY = 0;\r\n    } else {\r\n        deltaX = input.x - prevInput.x;\r\n        deltaY = input.y - prevInput.y;\r\n    }\r\n\r\n    // 计算deltaXAngle / deltaYAngle\r\n    if (0 !== deltaX || 0 !== deltaY) {\r\n        const deltaXY = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n        deltaXYAngle = Math.round(radianToAngle(Math.acos(Math.abs(deltaX) / deltaXY)));\r\n        cache.set({deltaXYAngle});\r\n    } else {\r\n        deltaXYAngle = cache.get('deltaXYAngle', 0);\r\n    }\r\n\r\n    return { deltaX, deltaY, deltaXYAngle };\r\n};","import { Input } from '../interface';\r\nimport cache from '../$_cache';\r\n\r\nexport default ({ pointLength, isFirst }: { pointLength:number, isFirst:boolean}): number => {\r\n    if (isFirst) {\r\n        cache.set({maxPointLength:pointLength});\r\n        return pointLength;\r\n    } else {\r\n        const maxLength = cache.get('maxPointLength', 0);\r\n        if (pointLength > maxLength) {\r\n            cache.set({maxPointLength:pointLength});\r\n        }\r\n\r\n        return cache.get('maxPointLength', 0)\r\n    }\r\n};","import { CLIENT_X, CLIENT_Y } from '../const';\r\nexport default (input: any): { x: number, y: number } => ({\r\n    x: input.points[1][CLIENT_X] - input.points[0][CLIENT_X],\r\n    y: input.points[1][CLIENT_Y] - input.points[0][CLIENT_Y]\r\n});","import { getVLength } from '../vector';\r\nexport default function ({\r\n    startV, prevV, activeV\r\n}: any): { scale: number, deltaScale: number } {\r\n    const deltaScale = getVLength(activeV) / getVLength(prevV);\r\n    const scale = getVLength(activeV) / getVLength(startV);\r\n    return { scale, deltaScale };\r\n};","import { getAngle } from '../vector';\r\nexport default function ({\r\n    startV, prevV, activeV\r\n}: any): { angle: number, deltaAngle: number } {\r\n    const deltaAngle = getAngle(activeV, prevV);\r\n    const angle = getAngle(activeV, startV);\r\n    return { angle, deltaAngle };\r\n};","\r\nimport computeVector from './computeVector';\r\nimport computeScale from './computeScale';\r\nimport computeAngle from './computeAngle';\r\nimport cache from '../$_cache';\r\n\r\nexport default function ({\r\n    startMultiInput,\r\n    prevInput,\r\n    input\r\n}: any): {\r\n    scale: number;\r\n    deltaScale: number;\r\n    angle: number;\r\n    deltaAngle: number\r\n} {\r\n    // 上一触点数大于1, 当前触点大于1\r\n    // 连续第二次出现多点, 才能开始计算\r\n    if (undefined !== prevInput && 1 < prevInput.points.length && 1 < input.points.length) {\r\n        // 2指形成的向量\r\n        const startV = computeVector(startMultiInput);\r\n        const prevV = computeVector(prevInput);\r\n        const activeV = computeVector(input);\r\n        // 计算缩放\r\n        const { scale, deltaScale } = computeScale({\r\n            startV, activeV, prevV\r\n        });\r\n\r\n        // ========= 计算旋转角度 =========\r\n        const { deltaAngle, angle } = computeAngle({ startV, prevV, activeV });\r\n        cache.set({ angle });\r\n        cache.set({ scale });\r\n        return { scale, deltaScale, deltaAngle, angle };\r\n    } else {\r\n        return {\r\n            scale: cache.get('scale', 1),\r\n            deltaScale: 1,\r\n            deltaAngle: 0,\r\n            angle: cache.get('angle', 0)\r\n        };\r\n    }\r\n};","\r\nimport { Computed, Input, directionString } from '../interface';\r\nimport { getDirection } from '../vector';\r\nimport intervalCompute from './intervalCompute';\r\nimport computeDistance from './computeDistance';\r\nimport computeDeltaXY from './computeDeltaXY';\r\nimport computeMaxLength from './computeMaxLength';\r\nimport computMulti from './computeMulti';\r\ntype Inputs = {\r\n    input: Input;\r\n    startInput: Input;\r\n    prevInput?: Input;\r\n    startMultiInput?: Input;\r\n}\r\n// 最大触点数\r\nexport default function (inputs: Inputs): Computed {\r\n    const { input } = inputs;\r\n    // ========= 整体距离/位移=========\r\n    const { displacementX, displacementY, distanceX, distanceY, distance, overallDirection } = computeDistance(inputs);\r\n\r\n    // ========= 已消耗时间 =========\r\n    const deltaTime = inputs.input.timestamp - inputs.startInput.timestamp;\r\n\r\n    // ========= 最近25ms内计算数据, 瞬时数据 =========\r\n    const { velocityX, velocityY, speedX, speedY, direction } = intervalCompute(inputs);\r\n\r\n    // ========= 中心点位移增量 =========\r\n    const { deltaX, deltaY, deltaXYAngle } = computeDeltaXY(inputs);\r\n\r\n\r\n    // ========= 多点计算 =========\r\n    // 上一触点数大于1, 当前触点大于1\r\n    // 连续第二次出现多点, 才能开始计算\r\n    const { scale,\r\n        deltaScale,\r\n        angle,\r\n        deltaAngle } = computMulti(inputs);\r\n\r\n    const maxPointLength = computeMaxLength(input);\r\n    return {\r\n        type: '',\r\n        ...input,\r\n        velocityX,\r\n        velocityY,\r\n        speedX,\r\n        speedY,\r\n        deltaTime,\r\n        overallDirection,\r\n        direction,\r\n        deltaX, deltaY, deltaXYAngle,\r\n        displacementX,\r\n        displacementY,\r\n        distanceX,\r\n        distanceY,\r\n        distance,\r\n        scale,\r\n        deltaScale,\r\n        angle,\r\n        deltaAngle,\r\n        maxPointLength \r\n    };\r\n};","export default (touchActions: string[]): string => {\r\n    // 表示优先级\r\n    const TOUCH_ACTION_PRIORITY: { [propName: string]: number } = {\r\n        auto: 0,\r\n        manipulation: 1,\r\n        'pan-x': 2,\r\n        'pan-y': 2,\r\n        none: 3\r\n    };\r\n\r\n    // 最大优先级\r\n    const MAX_PRIORITY = TOUCH_ACTION_PRIORITY['none'];\r\n\r\n    // 最终的有效的touch-action会放在数组中\r\n    let touchActionCSSArray: string[] = ['auto'];\r\n    // 上一步计算的touch-action的优先级\r\n    let prevPriority = 0;\r\n    for (let touchAction of touchActions) {\r\n\r\n        // 当前优先级\r\n        let activePriority = TOUCH_ACTION_PRIORITY[touchAction];\r\n\r\n        // 如果是最大优先级, 那么后面就不用计算了\r\n        if (MAX_PRIORITY === activePriority) {\r\n            touchActionCSSArray = [touchAction];\r\n            break;\r\n        }\r\n        // 当前优先级大, 那么覆盖touch-action\r\n        else if (prevPriority < activePriority) {\r\n            touchActionCSSArray = [touchAction];\r\n            prevPriority = activePriority;\r\n        }\r\n        // 如果相等那么加入当前touch-action, 例如pan-x/pan-y可以并存\r\n        else if (prevPriority === activePriority && 0 < activePriority) {\r\n            touchActionCSSArray.push(touchAction);\r\n            prevPriority = activePriority;\r\n        }\r\n        \r\n    }\r\n    return touchActionCSSArray.join(' ');\r\n};","// 识别器状态码\r\n// 注意: 此处的值会直接被事件名所用, 如panstart/panmove等等\r\nexport const STATUS_POSSIBLE = 'possible';\r\nexport const STATUS_START = 'start';\r\nexport const STATUS_MOVE = 'move';\r\nexport const STATUS_END = 'end';\r\nexport const STATUS_CANCELLED = 'cancel';\r\nexport const STATUS_FAILED = 'failed';\r\nexport const STATUS_RECOGNIZED = 'recognized';","import { Computed, directionString } from '../interface';\r\nimport { INPUT_CANCEL, INPUT_END, INPUT_MOVE } from '../const';\r\nimport {\r\n    STATUS_POSSIBLE,\r\n    STATUS_START,\r\n    STATUS_MOVE,\r\n    STATUS_END,\r\n    STATUS_CANCELLED,\r\n    STATUS_FAILED, STATUS_RECOGNIZED\r\n} from '../const/recognizerStatus';\r\n\r\nexport default abstract class Recognizer {\r\n    // 手势名\r\n    public name: string;\r\n    // 是否禁止\r\n    public disabled: boolean;\r\n    // 识别状态\r\n    public status: string;\r\n    // 是否已识别\r\n    public isRecognized: boolean;\r\n    // 选项\r\n    public options: { [propName: string]: any };\r\n    // 需要对应手势失败才能识别成功\r\n    public requireFailureRecognizers: any[];\r\n    // 存储外部注入方法的容器\r\n    public $root: any;\r\n\r\n    public eventEmitter: any;\r\n\r\n    constructor(options: { name?: string, [k: string]: any }) {\r\n        this.options = { ...(<any>this.constructor).DEFAULT_OPTIONS, disabled: false, ...options };\r\n        this.name = this.options.name;\r\n        this.disabled = this.options.disabled;\r\n        this.status = STATUS_POSSIBLE;\r\n        this.isRecognized = false;\r\n        this.requireFailureRecognizers = [];\r\n        // 这里面不能直接调用$root等, \r\n        // 因为rollup生成的代码构造函数并不是该constructor\r\n        // 而是构造函数中又嵌套了一个同名构造函数\r\n    };\r\n\r\n    /**\r\n     * 设置识别器\r\n     * @param {Object} 选项 \r\n     */\r\n    public set(options = {}) {\r\n        this.options = { ...this.options, ...options };\r\n        // 刷新anyTouch\r\n        this.$root.update();\r\n        return this;\r\n    };\r\n\r\n    public $injectRoot($root: any) {\r\n        this.$root = $root;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * 对eventEmitter进行封装\r\n     * @param type \r\n     * @param payload \r\n     */\r\n    public emit(type: string, payload: any) {\r\n        payload.type = type;\r\n        this.$root.eventEmitter.emit(type, payload);\r\n        if (this.$root.options.hasDomEvents) {\r\n            // 过滤掉几个Event上保留的字段\r\n            let { target, currentTarget, type, ...data } = payload;\r\n            let event = new Event(type, payload);\r\n            Object.assign(event, data);\r\n            this.$root.el.dispatchEvent(event);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 前者需要后者识别失败才能触发\r\n     * @param {Recognizer} 识别器实例 \r\n     */\r\n    public requireFailure(recognizer: this) {\r\n        if (!this.requireFailureRecognizers.includes(recognizer)) {\r\n            this.requireFailureRecognizers.push(recognizer);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 移除识别器之间的\"需要失败\"关系\r\n     *  @param {Recognizer} 识别器实例 \r\n     */\r\n    public removeRequireFailure(recognizer: Recognizer) {\r\n        for (let [index, requireFailureRecognizer] of this.requireFailureRecognizers.entries()) {\r\n            if (requireFailureRecognizer.name === recognizer.name) {\r\n                this.requireFailureRecognizers.splice(index, 1);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 是否需要其他手势失败才能触发\r\n     */\r\n    public hasRequireFailure() {\r\n        return 0 < this.requireFailureRecognizers.length;\r\n    };\r\n\r\n    /**\r\n     * 是否所有\"需要失败\"的手势都是disabled的\r\n     */\r\n    public isAllRequireFailureRecognizersDisabled(){\r\n        return this.requireFailureRecognizers.every((recognizer:any)=>recognizer.disabled);\r\n    };\r\n\r\n    /**\r\n     * 是否要求注册时指定失败的选择器是失败状态\r\n     */\r\n    public isAllRequiresFailedOrPossible(): boolean {\r\n        for (let recognizer of this.requireFailureRecognizers) {\r\n            if (STATUS_FAILED !== recognizer.status && STATUS_POSSIBLE !== recognizer.status) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * 验证触点\r\n     * @param {Number} 触点数\r\n     */\r\n    public isValidPointLength(pointLength: number): boolean {\r\n        return 0 === this.options.pointLength || this.options.pointLength === pointLength\r\n    };\r\n\r\n    /**\r\n     * 是否只支持水平方向\r\n     */\r\n    public isOnlyHorizontal() {\r\n        let isOnlyHorizontal = true;\r\n        for (let direction of this.options.directions) {\r\n            isOnlyHorizontal = -1 < ['left', 'right'].indexOf(direction);\r\n            if (!isOnlyHorizontal) {\r\n                return false;\r\n            }\r\n        }\r\n        return isOnlyHorizontal;\r\n    };\r\n\r\n    /**\r\n     * 是否只支持垂直方向\r\n     */\r\n    public isOnlyVertical() {\r\n        let isOnlyVertical = true;\r\n        for (let direction of this.options.directions) {\r\n            isOnlyVertical = -1 < ['up', 'down'].indexOf(direction);\r\n            if (!isOnlyVertical) {\r\n                return false;\r\n            }\r\n        }\r\n        return isOnlyVertical;\r\n    };\r\n\r\n    /**\r\n     * 是否支持该方向\r\n     * @param {String} 方向 \r\n     */\r\n    public isVaildDirection(direction?: directionString) {\r\n        return -1 !== this.options.directions.indexOf(direction) || 'none' === direction;\r\n    };\r\n\r\n    public flow(isVaild: boolean, activeStatus: string, touchDevice: string): string {\r\n        // if(this.name ==='swipe' ) {\r\n        //     console.log(isVaild, activeStatus, touchDevice);\r\n        // }\r\n        const STATE_MAP: { [k: number]: any } = {\r\n            // isVaild === true,\r\n            // Number(true) === 1\r\n            // 这个分支不会出现STATUS_FAILED\r\n            // STATUS_END在上面的代码中也会被重置为STATUS_POSSIBLE, 从而进行重新识别\r\n            1: {\r\n                [STATUS_POSSIBLE]: {\r\n                    [INPUT_MOVE]: STATUS_START,\r\n                    [INPUT_END]: STATUS_RECOGNIZED,\r\n                    [INPUT_CANCEL]: STATUS_CANCELLED\r\n                },\r\n                [STATUS_START]: {\r\n                    [INPUT_MOVE]: STATUS_MOVE,\r\n                    [INPUT_END]: STATUS_END,\r\n                    [INPUT_CANCEL]: STATUS_CANCELLED\r\n                },\r\n                [STATUS_MOVE]: {\r\n                    [INPUT_MOVE]: STATUS_MOVE,\r\n                    [INPUT_END]: STATUS_END,\r\n                }\r\n            },\r\n            // isVaild === false\r\n            // 这个分支有STATUS_FAILED\r\n            0: {\r\n                [STATUS_START]: {\r\n                    [INPUT_MOVE]: STATUS_CANCELLED,\r\n                    [INPUT_END]: STATUS_END,\r\n                    [INPUT_CANCEL]: STATUS_CANCELLED\r\n                },\r\n                [STATUS_MOVE]: {\r\n                    [INPUT_MOVE]: STATUS_CANCELLED,\r\n                    [INPUT_END]: STATUS_END,\r\n                    [INPUT_CANCEL]: STATUS_CANCELLED\r\n                }\r\n            }\r\n        };\r\n        // console.warn(Number(isVaild),activeStatus, STATE_MAP[Number(isVaild)][activeStatus]);\r\n        if (undefined !== STATE_MAP[Number(isVaild)][activeStatus]) {\r\n            return STATE_MAP[Number(isVaild)][activeStatus][touchDevice] || activeStatus;\r\n        } else {\r\n            return activeStatus;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 如果识别结束, 那么重置状态\r\n     */\r\n    protected _resetStatus() {\r\n        // if (this.name === 'tap') console.log('@', this.status);\r\n        //STATUS_RECOGNIZED === STATUS_END\r\n        if (-1 !== [STATUS_END, STATUS_CANCELLED, STATUS_RECOGNIZED, STATUS_FAILED].indexOf(this.status)) {\r\n\r\n            this.status = STATUS_POSSIBLE;\r\n        };\r\n    };\r\n\r\n    /**\r\n     * 适用于大部分移动类型的手势, \r\n     * 如pan/rotate/pinch/swipe\r\n     * @param {Computed} 计算数据 \r\n     */\r\n    recognize(computed: Computed) {\r\n        // if(this.name === 'pan')    console.log(this.name,this.status);\r\n        // 是否识别成功\r\n        let isVaild = this.test(computed);\r\n\r\n        // 重置status\r\n        this._resetStatus();\r\n\r\n        // 状态变化流程\r\n        let { eventType } = computed;\r\n\r\n        this.status = this.flow(isVaild, this.status, eventType);\r\n\r\n        if (STATUS_CANCELLED === this.status) {\r\n            this.emit(this.options.name + 'cancel', computed);\r\n            return;\r\n        }\r\n\r\n        // 是否已识别\r\n        this.isRecognized = -1 < [STATUS_START, STATUS_MOVE, STATUS_END, STATUS_RECOGNIZED].indexOf(this.status);\r\n        // 识别后触发的事件\r\n        if (this.isRecognized) {\r\n            this.afterRecognized(computed);\r\n            // computed = this.lockDirection(computed);d\r\n            this.emit(this.options.name, computed);\r\n            // console.log(this.options.name, computed);\r\n            if (-1 < [STATUS_START, STATUS_MOVE, STATUS_END, STATUS_RECOGNIZED].indexOf(this.status)) {\r\n                // panstart | panmove | panend等\r\n                this.emit(this.options.name + this.status, computed);\r\n                this.afterEmit(computed);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 识别条件, 基于异步\r\n     * @param {Computed} 计算数据\r\n     * @param {(isRecognized: boolean) => void}} 接收是否识别状态\r\n     */\r\n    abstract test(computed: Computed): boolean;\r\n\r\n    /**\r\n     * 识别成功后执行\r\n     * 这个阶段可以对computed数据做些处理\r\n     * 比如pan可以针对不支持的方向吧deltaX/Y调整为0\r\n     * swipe可以把不支持的方向上的速率调整为0\r\n     * @param {Computed} 计算数据 \r\n     */\r\n    public afterRecognized(computed: Computed): void { };\r\n\r\n    /**\r\n     * 基类的所有emit触发后执行\r\n     * @param {Computed} computed \r\n     */\r\n    public afterEmit(computed: Computed): void { };\r\n\r\n    /**\r\n     * 计算当前手势的touch-action\r\n     */\r\n    abstract getTouchAction(): string[];\r\n};\r\n\r\n","import { Computed, Point } from '../interface';\r\nimport {\r\n    STATUS_RECOGNIZED, STATUS_POSSIBLE,\r\n    STATUS_FAILED,\r\n    STATUS_START,\r\n} from '../const/recognizerStatus';\r\nconst { setTimeout, clearTimeout } = window;\r\nimport Recognizer from './Base';\r\nimport { INPUT_END } from '../const';\r\nimport { getVLength } from '../vector';\r\nexport default class TapRecognizer extends Recognizer {\r\n    public tapCount: number;\r\n\r\n\r\n    // 记录每次单击完成时的坐标\r\n    public prevTapPoint?: Point;\r\n    public prevTapTime?: number;\r\n\r\n    // 多次tap之间的距离是否满足要求\r\n    public isValidDistanceFromPrevTap?: boolean;\r\n\r\n    // timer\r\n    private _delayFailTimer?: number;\r\n    private _waitOtherFailedTimer?: number;\r\n    private _time?: number;\r\n\r\n    static DEFAULT_OPTIONS = {\r\n        name: 'tap',\r\n        pointLength: 1,\r\n        tapTimes: 1,\r\n        // 等待下一次tap的时间, \r\n        // 超过该事件就立即判断当前点击数量\r\n        waitNextTapTime: 300,\r\n        disabled: false,\r\n        // 从接触到离开允许产生的最大距离\r\n        positionTolerance: 2,\r\n        // 2次tap之间允许的最大位移\r\n        tapsPositionTolerance: 9,\r\n        // 从接触到离开屏幕的最大时间\r\n        maxPressTime: 250,\r\n    };\r\n    constructor(options = {}) {\r\n        super(options);\r\n        this.tapCount = 0;\r\n    };\r\n\r\n    public getTouchAction() {\r\n        // 单击auto, 多击manipulation=pan + pinch-zoom(禁用了默认双击)\r\n        return (1 < this.options.tapTimes) ? ['manipulation'] : ['auto'];\r\n    };\r\n\r\n    /**\r\n     * 判断前后2次点击的距离是否超过阈值\r\n     * @param {Point} 当前触点\r\n     * @return {Boolean} 前后2次点击的距离是否超过阈值\r\n     */\r\n    private _isValidDistanceFromPrevTap(point: Point): boolean {\r\n        // 判断2次点击的距离\r\n        if (undefined !== this.prevTapPoint) {\r\n            const distanceFromPreviousTap = getVLength({ x: point.x - this.prevTapPoint.x, y: point.y - this.prevTapPoint.y });\r\n            // 缓存当前点, 作为下次点击的上一点\r\n            this.prevTapPoint = point;\r\n            return this.options.tapsPositionTolerance >= distanceFromPreviousTap;\r\n        } else {\r\n            this.prevTapPoint = point;\r\n            return true;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 校验2次tap的时间间隔是否满足\r\n     * @return {Boolean} 是否满足\r\n     */\r\n    private _isValidInterval(): boolean {\r\n        const now = Date.now();\r\n        if (undefined === this.prevTapTime) {\r\n            this.prevTapTime = now;\r\n            return true;\r\n        } else {\r\n            const interval = now - this.prevTapTime;\r\n            this.prevTapTime = now;\r\n            return interval < this.options.waitNextTapTime;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * function filter(input, include, exclude){\r\n     *\tconst rule = new RegExp(`^((?!${exclude}).)*${include}((?!${exclude}).)*$`);\r\n     *\treturn rule.test(input);\r\n     *}\r\n     * 230106198601300833\r\n     * /\\d{,6}[1-2]\\d\\/\r\n     * 识别后执行    \r\n     *             开始   \r\n     *              |\r\n     *         <是否end阶段> - 否 - 结束\r\n     *              |\r\n     *          关闭定时器c1和c2\r\n     *              |\r\n     *              是\r\n     *              |\r\n     *        重置状态为\"可能是\"\r\n     *              |\r\n     *        <是否满足单击条件> - 否 - 结束\r\n     *              |\r\n     *              是\r\n     *              |\r\n     *       <是否正确连击：是否上次点击信息为空 或 与上次点击的位移/时间是否满足约束> - 否 - 点击次数=1 - 继续(<是否到达点击数要求>)\r\n     *              |\r\n     *              是\r\n     *              |\r\n     *           点击次数+1\r\n     *              |\r\n     *       <是否到达点击数要求> - 否 - 设置定时器c1(t1毫秒后状态设置为\"失败\") - 结束\r\n     *              |\r\n     *              是\r\n     *              |\r\n     *      <是否需要其他手势失败> - 否 - 触发事件, 状态设置为\"已识别\",重置(点击次数,位置) - 结束\r\n     *              |\r\n     *              是\r\n     *              |\r\n     *  <设置定时器c2(t1毫秒后检查\"需要失败\"的手势是否是\"失败\"状态, 重置(点击次数,位置)> - 否 - 设置状态为\"失败\" - 结束\r\n     *              |\r\n     *              是\r\n     *              |\r\n     *       触发, 状态设置为\"已识别\", 重置(点击次数,位置)\r\n     *              |\r\n     *             结束\r\n     * \r\n     * @param {Computed} 计算数据 \r\n     */\r\n\r\n    public recognize(computed: Computed): void {\r\n        // 只在end阶段去识别\r\n        if (INPUT_END !== computed.eventType) return;\r\n        \r\n        this.status = STATUS_POSSIBLE;\r\n\r\n        // 每一次点击是否符合要求\r\n        if (this.test(computed)) {\r\n            clearTimeout(this._delayFailTimer);\r\n            clearTimeout(this._waitOtherFailedTimer);\r\n            // 判断2次点击之间的距离是否过大\r\n            // 对符合要求的点击进行累加\r\n            if (this._isValidDistanceFromPrevTap(computed) && this._isValidInterval()) {\r\n                this.tapCount++;\r\n            } else {\r\n                this.tapCount = 1;\r\n            }\r\n            'tap' === this.name && console.log(this.name, this.tapCount)\r\n\r\n            // 是否满足点击次数要求\r\n            if (this.tapCount === this.options.tapTimes) {\r\n                if (this.hasRequireFailure() && !this.isAllRequireFailureRecognizersDisabled()) {\r\n                    this._waitOtherFailedTimer = setTimeout(() => {\r\n                        // 检查指定手势是否识别为Failed\r\n                        if (this.isAllRequiresFailedOrPossible()) {\r\n                            this.status = STATUS_RECOGNIZED;\r\n                            this.emit(this.options.name, { ...computed, tapCount: this.tapCount });\r\n                        } else {\r\n                            this.status = STATUS_FAILED;\r\n                        };\r\n                        // 不论成功失败都要重置tap计数\r\n                    }, this.options.waitNextTapTime);\r\n                }\r\n                // 如果不需要等待其他手势失败\r\n                // 那么立即执行\r\n                else {\r\n                    this.status = STATUS_RECOGNIZED;\r\n                    this.emit(this.options.name, { ...computed, tapCount: this.tapCount });\r\n                    this.reset();\r\n                }\r\n            } else {\r\n                this._delayFailTimer = setTimeout(() => {\r\n                    this.status = STATUS_FAILED;\r\n                    this.reset();\r\n                }, this.options.waitNextTapTime);\r\n            }\r\n        } else {\r\n            this.reset();\r\n            this.status = STATUS_FAILED;\r\n        }\r\n    };\r\n\r\n    public reset() {\r\n        this.tapCount = 0;\r\n        this.prevTapPoint = undefined;\r\n        this.prevTapTime = undefined;\r\n    };\r\n\r\n    /**\r\n     * 指定时间后, 设置状态为失败\r\n     */\r\n    private _delayFail(cb: () => void = () => { }) {\r\n        this._delayFailTimer = setTimeout(() => {\r\n            this.status = STATUS_FAILED;\r\n            cb();\r\n        }, this.options.waitNextTapTime);\r\n    };\r\n\r\n    /**\r\n     * 取消延迟失败定时\r\n     */\r\n    private _cancelDelayFail() {\r\n        clearTimeout(this._delayFailTimer);\r\n    };\r\n\r\n    /**\r\n      * 识别条件\r\n      * @param {Computed} 计算数据\r\n      * @return {Boolean} 是否验证成功\r\n      */\r\n    public test(computed: Computed): boolean {\r\n        // 判断是否发生大的位置变化\r\n        const { distance, deltaTime, maxPointLength } = computed;\r\n        // 检查\r\n        // 1. 触点数\r\n        // 2. 移动距离\r\n        // 3. start至end的事件, 区分tap和press\r\n        return maxPointLength === this.options.pointLength &&\r\n            this.options.positionTolerance >= distance &&\r\n            this.options.maxPressTime > deltaTime;\r\n    };\r\n\r\n    public afterEmit(computed: Computed): void { }\r\n};","import { Computed } from '../interface';\r\nimport {\r\n    STATUS_FAILED, STATUS_RECOGNIZED\r\n} from '../const/recognizerStatus';\r\nimport { INPUT_CANCEL, INPUT_END, INPUT_START } from '../const';\r\nimport Recognizer from './Base';\r\nexport default class PressRecognizer extends Recognizer {\r\n    private _timeoutId?: number;\r\n    static DEFAULT_OPTIONS = {\r\n        name: 'press',\r\n        pointLength: 1,\r\n        positionTolerance: 9,\r\n        minPressTime: 251,\r\n    };\r\n    constructor(options = {}) {\r\n        super(options);\r\n    };\r\n\r\n    getTouchAction(): string[] {\r\n        return ['auto'];\r\n    };\r\n\r\n    recognize(computed: Computed): void {\r\n        const { eventType, pointLength, distance, deltaTime } = computed;\r\n\r\n        // 1. start阶段\r\n        // 2. 触点数符合\r\n        // 那么等待minPressTime时间后触发press\r\n        if (INPUT_START === eventType && this.isValidPointLength(pointLength)) {\r\n            // 重置状态\r\n            this._resetStatus();\r\n            // 延迟触发\r\n            this.cancel();\r\n            this._timeoutId = window.setTimeout(() => {\r\n                this.status = STATUS_RECOGNIZED;\r\n                this.emit(this.options.name, computed);\r\n            }, this.options.minPressTime);\r\n        }\r\n\r\n        // 触发pressup条件:\r\n        // 1. end阶段\r\n        // 2. 已识别\r\n        else if (INPUT_END === eventType && STATUS_RECOGNIZED === this.status) {\r\n            this.emit(`${this.options.name}up`, computed);\r\n        }\r\n\r\n        // 一旦不满足必要条件, 触发失败\r\n        // 对应cancel和end阶段\r\n        else if (!this.test(computed) || (this.options.minPressTime > deltaTime && -1 !== [INPUT_END, INPUT_CANCEL].indexOf(eventType) )) {\r\n            this.cancel();\r\n            this.status = STATUS_FAILED;\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 是否满足:\r\n     * 移动距离不大\r\n     */\r\n    test({ distance}: Computed): boolean {\r\n        return this.options.positionTolerance > distance;\r\n    };\r\n\r\n    cancel(): void {\r\n        clearTimeout(this._timeoutId);\r\n    }\r\n\r\n    afterEmit() { }\r\n};","/**\r\n * 获取数组中方向是否水平/垂直\r\n * @param {directionString[]} 方向数组, ['left', 'right','up', 'down']\r\n * \r\n */\r\nimport {directionString} from '../interface';\r\nexport default (directions: [directionString?, directionString?, directionString?, directionString?]): { hasHorizontal: boolean, hasVertical: boolean } => {\r\n    let hasHorizontal = false;\r\n    let hasVertical = false;\r\n    for (let direction of directions) {\r\n        if (-1 < ['left', 'right'].indexOf(<string>direction)) {\r\n            hasHorizontal = true;\r\n            if (hasVertical) break;\r\n        } else if (-1 < ['up', 'down'].indexOf(<string>direction)) {\r\n            hasVertical = true;\r\n            if (hasHorizontal) break;\r\n        } else {\r\n            throw new Error('wrong direction!');\r\n        }\r\n    };\r\n    return { hasHorizontal, hasVertical };\r\n};","import { Computed, directionString } from '../interface';\r\nimport { INPUT_MOVE } from '../const';\r\nimport Recognizer from './Base';\r\nimport getHV from '../untils/getHV';\r\n\r\nexport default class PanRecognizer extends Recognizer {\r\n    static DEFAULT_OPTIONS = {\r\n        name: 'pan',\r\n        threshold: 10,\r\n        pointLength: 1,\r\n        directions: ['up', 'right', 'down', 'left']\r\n    };\r\n    constructor(options = {}) {\r\n        super(options);\r\n    };\r\n\r\n    getTouchAction() {\r\n        let touchActions = ['auto'];\r\n        let { hasHorizontal, hasVertical } = getHV(this.options.directions);\r\n        if (hasHorizontal && hasVertical) {\r\n            touchActions = ['none'];\r\n        } else if (!hasHorizontal && hasVertical) {\r\n            // 没有水平移动\r\n            touchActions = ['pan-x'];\r\n        } else if (!hasVertical && hasHorizontal) {\r\n            // 没有垂直移动\r\n            touchActions = ['pan-y'];\r\n        }\r\n        return touchActions;\r\n    };\r\n\r\n    /**\r\n     * @param {Computed} 计算数据\r\n     * @return {Boolean}} .是否是当前手势 \r\n     */\r\n    test({ distance, direction, eventType, pointLength }: Computed): boolean {\r\n        return INPUT_MOVE === eventType &&\r\n            (this.isRecognized || this.options.threshold < distance) &&\r\n            this.isValidPointLength(pointLength) &&\r\n            this.isVaildDirection(direction);\r\n    };\r\n\r\n    /**\r\n     * 识别后发布panleft等事件\r\n     * @param {Computed} 计算数据\r\n     */\r\n    afterEmit(computed: Computed) {\r\n        if ('none' !== computed.direction) {\r\n            this.emit(this.options.name + computed.direction, computed);\r\n        }\r\n    };\r\n\r\n    afterRecognized(computed: Computed) {\r\n        this.lockDirection(computed);\r\n    }\r\n\r\n    /**\r\n     * 移除限制方向的deltaX/Y\r\n     * @param {Computed} computed \r\n     */\r\n    public lockDirection(computed: Computed): Computed {\r\n        if (undefined === this.options.directions || 0 === this.options.directions.length) return computed;\r\n        let deltaX = 0;\r\n        let deltaY = 0;\r\n        this.options.directions.forEach((direction: string) => {\r\n            if ('left' === direction && 0 > computed.deltaX) {\r\n                deltaX = computed.deltaX;\r\n            } else if ('right' === direction && 0 < computed.deltaX) {\r\n                deltaX = computed.deltaX;\r\n            } else if ('down' === direction && 0 < computed.deltaY) {\r\n                deltaY = computed.deltaY;\r\n            } else if ('up' === direction && 0 > computed.deltaY) {\r\n                deltaY = computed.deltaY;\r\n            }\r\n        });\r\n        computed.deltaX = deltaX;\r\n        computed.deltaY = deltaY;\r\n        return computed;\r\n    };\r\n};","import Recognizer from './Base';\r\nimport { Computed } from '../interface';\r\nimport { INPUT_END } from '../const';\r\nexport default class SwipeRecognizer extends Recognizer {\r\n    static DEFAULT_OPTIONS = {\r\n        name: 'swipe',\r\n        threshold: 10,\r\n        velocity: 0.3,\r\n        pointLength: 1,\r\n        directions: ['up', 'right', 'down', 'left']\r\n    };\r\n    constructor(options = {}) {\r\n        super(options);\r\n    };\r\n\r\n    getTouchAction() {\r\n        return ['none'];\r\n    };\r\n\r\n    /**\r\n     * 识别后发布swipeleft等事件\r\n     * @param {Computed} 计算数据\r\n     */\r\n    afterEmit(computed: Computed) {\r\n        if ('none' !== computed.direction) {\r\n            this.emit(this.options.name + computed.direction, computed);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 识别条件\r\n     * @param {Computed} 计算数据\r\n     */\r\n    test(computed: Computed): boolean {\r\n        if (INPUT_END !== computed.eventType) return false;\r\n\r\n        // 非end阶段, 开始校验数据\r\n        const { direction, velocityX, velocityY, maxPointLength, distance } = computed;\r\n        // 如果只支持水平或垂直, 那么其他方向速率为0;\r\n        // 有效速率\r\n        let vaildVelocityX: number = velocityX;\r\n        let vaildVelocityY: number = velocityY;\r\n        if (this.isOnlyHorizontal()) {\r\n            vaildVelocityY = 0;\r\n        } else if (this.isOnlyVertical()) {\r\n            vaildVelocityX = 0;\r\n        }\r\n\r\n        let vaildVelocity = Math.sqrt(vaildVelocityX * vaildVelocityX + vaildVelocityY * vaildVelocityY)\r\n\r\n        return 1 === maxPointLength &&\r\n            this.options.threshold < distance &&\r\n            this.isVaildDirection(direction) &&\r\n            this.options.velocity < vaildVelocity;\r\n    };\r\n};","import { Computed } from '../interface';\r\nimport Recognizer from './Base';\r\n\r\n\r\nexport default class PinchRecognizer extends Recognizer {\r\n    private _prevScale: number;\r\n    static DEFAULT_OPTIONS = {\r\n        name: 'pinch',\r\n        // 触发事件所需要的最小缩放比例\r\n        threshold: 0,\r\n        pointLength: 2,\r\n    };\r\n    constructor(options={}) {\r\n        super(options);\r\n        this._prevScale = 1;\r\n    };\r\n    \r\n    getTouchAction(){\r\n        return ['none'];\r\n    };\r\n\r\n    afterEmit(computed: Computed) {\r\n        if('end' === computed.eventType) return;\r\n        // pinchin | pinchout\r\n        const { scale } = computed;\r\n        if (1 !== scale) {\r\n            const inOrOut = scale > this._prevScale ? 'out' : 'in';\r\n            this.emit(this.options.name + inOrOut, computed);\r\n        }\r\n        this._prevScale = scale;\r\n    };\r\n\r\n    /**\r\n     * 识别条件\r\n     * @param {Computed} 计算数据\r\n     * @param {(isRecognized: boolean) => void}} 接收是否识别状态\r\n     */\r\n    test({ pointLength, scale }: Computed): boolean {\r\n        // 如果触碰点数要大于指定\r\n        // 如果缩放超过阈值, 或者已识别\r\n        // console.log({scale})\r\n        return this.isValidPointLength(pointLength) && (this.options.threshold < Math.abs(scale-1) || this.isRecognized);\r\n    };\r\n};","import Base from './Base';\r\nimport { Computed } from '../interface';\r\nexport default class RotateRecognizer extends Base {\r\n    static DEFAULT_OPTIONS = {\r\n        name: 'rotate',\r\n        // 触发事件所需要的最小角度\r\n        threshold: 0,\r\n        pointLength: 2,\r\n    };\r\n    constructor(options = {}) {\r\n        super(options);\r\n    };\r\n\r\n    getTouchAction() {\r\n        return ['none'];\r\n    };\r\n\r\n    /**\r\n     * 无特殊事件要触发\r\n     */\r\n    afterEmit(computed: Computed) { };\r\n\r\n    /**\r\n     * 识别条件\r\n     * @param {Computed} 计算数据\r\n     * @return {Boolean} 接收是否识别状态\r\n     */\r\n    test({ pointLength, angle }: Computed): boolean {\r\n        // 如果触碰点数要大于指定\r\n        // 如果缩放超过阈值, 或者已识别\r\n        return this.isValidPointLength(pointLength) && (this.options.threshold < Math.abs(angle) || this.isRecognized);\r\n    };\r\n};","/**\r\n * ==================== 参考 ====================\r\n * https://segmentfault.com/a/1190000010511484#articleHeader0\r\n * https://segmentfault.com/a/1190000007448808#articleHeader1\r\n * hammer.js\r\n * \r\n * ==================== 支持的手势 ====================\r\n * rotate 旋转\r\n * pinch 捏合,\r\n * tap 单机\r\n * doubleTap 双击\r\n * press 按压\r\n * pan 拖拽\r\n * swipe 快划\r\n * \r\n * ==================== 流程 ====================\r\n * 格式化Event成统一的pointer格式 => 通过pointer数据计算 => 用计算结果去识别手势\r\n */\r\nimport { Computed } from './interface';\r\nimport AnyEvent from 'any-event';\r\nimport { SUPPORT_TOUCH } from './const';\r\nimport InputManage from './InputManage';\r\nimport compute from './compute/index';\r\nimport computeTouchAction from './untils/computeTouchAction';\r\nimport cache from './$_cache';\r\n\r\n// 识别器\r\nimport Recognizer from './recognitions/Base';\r\nimport Tap from './recognitions/Tap';\r\nimport Press from './recognitions/Press';\r\nimport Pan from './recognitions/Pan';\r\nimport Swipe from './recognitions/Swipe';\r\nimport Pinch from './recognitions/Pinch';\r\nimport Rotate from './recognitions/Rotate';\r\nimport * as Vector from './vector';\r\ninterface Options {\r\n    touchAction?: 'compute' | 'auto' | 'manipulation' | 'pan-x' | 'pan-y' | 'none';\r\n    hasDomEvents?: boolean;\r\n    isPreventDefault?: boolean;\r\n    style?: { [key: string]: string };\r\n};\r\nexport class AnyTouch {\r\n    // 识别器\r\n    static Tap = Tap;\r\n    static Press = Press;\r\n    static Pan = Pan;\r\n    static Swipe = Swipe;\r\n    static Pinch = Pinch;\r\n    static Rotate = Rotate;\r\n    static version = '__VERSION__';\r\n\r\n    // 向量计算\r\n    static Vector = Vector;\r\n\r\n    // mini的事件触发器\r\n    static EventEmitter = AnyEvent;\r\n\r\n    // 目标元素\r\n    el: HTMLElement;\r\n\r\n    default: Options;\r\n\r\n    touchDevice: string;\r\n\r\n    recognizers: Recognizer[];\r\n\r\n    options: Options;\r\n\r\n\r\n    eventEmitter: AnyEvent;\r\n\r\n    inputManage: InputManage;\r\n\r\n\r\n    // 是否阻止后面的识别器运行\r\n    private _isStopped: boolean;\r\n\r\n    /**\r\n     * @param {Element} 目标元素\r\n     * @param {Object} 选项\r\n     */\r\n    constructor(el: HTMLElement, options?: Options) {\r\n        this.default = {\r\n            touchAction: 'compute',\r\n            hasDomEvents: true,\r\n            isPreventDefault: false,\r\n            style: {\r\n                // 禁用选择文字\r\n                '-moz-user-select': 'none',\r\n                ' -webkit-user-select': 'none',\r\n                '-ms-user-select': 'none',\r\n                'user-select': 'none',\r\n                // https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-touch-select\r\n                // 禁用选择文字, 在winphone下\r\n                '-ms-touch-select': 'none',\r\n                // 点击元素的高亮颜色配置\r\n                '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\r\n                ' -webkit-user-drag': 'none',\r\n                // 当你触摸并按住触摸目标时候，\r\n                // 禁止或显示系统默认菜单。\r\n                // 在iOS上，当你触摸并按住触摸的目标，\r\n                // 比如一个链接，Safari浏览器将显示链接有关的系统默认菜单。\r\n                // 这个属性可以让你禁用系统默认菜单。\r\n                '-webkit-touch-callout': 'none'\r\n            }\r\n        };\r\n        this.el = el;\r\n        this.inputManage = new InputManage();\r\n        this.touchDevice = SUPPORT_TOUCH ? 'touch' : 'mouse';\r\n        this.options = { ...this.default, ...options };\r\n        // eventEmitter\r\n        this.eventEmitter = new AnyEvent();\r\n        this._isStopped = false;\r\n        // 初始化cache\r\n        cache.reset();\r\n        // 识别器\r\n        // 注入当前方法和属性, 方便在识别器中调用类上的方法和属性\r\n        this.recognizers = [\r\n            new Rotate().$injectRoot(this),\r\n            new Pinch().$injectRoot(this),\r\n            new Pan().$injectRoot(this),\r\n            new Swipe().$injectRoot(this),\r\n            new Tap().$injectRoot(this),\r\n            new Tap({\r\n                name: 'doubletap',\r\n                pointLength: 1,\r\n                tapTimes: 2,\r\n                disabled: true\r\n            }).$injectRoot(this),\r\n            new Press().$injectRoot(this),\r\n        ];\r\n        // 默认单击需要双击识别失败后触发\r\n        this.recognizers[4].requireFailure(this.recognizers[5]);\r\n        // 应用设置\r\n        this.update();\r\n        // 绑定事件\r\n        this.unbind = this._bindRecognizers(this.el).unbind;\r\n    };\r\n\r\n\r\n    /**\r\n     * 计算touch-action\r\n     * @param {HTMLElement} 目标元素 \r\n     */\r\n    private _updateTouchAction() {\r\n        if ('compute' === this.options.touchAction) {\r\n            let touchActions = [];\r\n            for (let recognizer of this.recognizers) {\r\n                touchActions.push(...recognizer.getTouchAction());\r\n            };\r\n            this.el.style.touchAction = computeTouchAction(touchActions);\r\n        } else {\r\n            this.el.style.touchAction = this.options.touchAction || 'auto';\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 应用几个提高体验的样式\r\n     * 如: 禁止选择文字/透明点击高亮颜色等\r\n     */\r\n    private _updateStyle() {\r\n        for (let key in this.options.style) {\r\n            let value = this.options.style[key];\r\n            (this.el.style as any)[key] = value;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 更新设置\r\n     */\r\n    public update() {\r\n        this._updateStyle();\r\n        this._updateTouchAction();\r\n    };\r\n\r\n    /**\r\n     * 绑定手势到指定元素\r\n     * 暂时只支持事件冒泡阶段触发, \r\n     * 改为捕获阶段需要对inputListener进行编号, \r\n     * 产生大量事件绑定,\r\n     * 而非在一次触发事件中执行所有手势判断\r\n     * @param {Element} 待绑定手势元素\r\n     */\r\n    private _bindRecognizers(el: Element) {\r\n        const boundInputListener = this.inputListener.bind(this);\r\n        // Touch\r\n        if ('touch' === this.touchDevice) {\r\n            const events = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\r\n            events.forEach(eventName => {\r\n                el.addEventListener(eventName, boundInputListener);\r\n            });\r\n            return {\r\n                unbind: () => {\r\n                    events.forEach(eventName => {\r\n                        el.removeEventListener(eventName, boundInputListener);\r\n                    });\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        // Mouse\r\n        else {\r\n            el.addEventListener('mousedown', boundInputListener);\r\n            window.addEventListener('mousemove', boundInputListener);\r\n            window.addEventListener('mouseup', boundInputListener);\r\n            return {\r\n                unbind: () => {\r\n                    el.removeEventListener('mousedown', boundInputListener);\r\n                    window.removeEventListener('mousemove', boundInputListener);\r\n                    window.removeEventListener('mouseup', boundInputListener);\r\n                }\r\n            };\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 添加识别器\r\n     * @param recognizer 识别器\r\n     */\r\n    add(recognizer: Recognizer): void {\r\n        recognizer.$injectRoot(this);\r\n        const hasSameName = this.recognizers.some((theRecognizer: Recognizer) => recognizer.name === theRecognizer.name);\r\n        if (hasSameName) {\r\n            this.eventEmitter.emit('error', { code: 1, message: `${recognizer.name}识别器已经存在!` })\r\n        } else {\r\n            this.recognizers.push(recognizer);\r\n            this.update();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 获取识别器通过名字\r\n     * @param {String} 识别器的名字\r\n     * @return {Recognizer|undefined} 返回识别器\r\n     */\r\n    get(name: string): Recognizer | undefined {\r\n        return this.recognizers.find(recognizer => name === recognizer.options.name);\r\n    };\r\n\r\n    /**\r\n     * 设置\r\n     * @param {Options} 选项 \r\n     */\r\n    set(options: Options): void {\r\n        this.options = { ...this.default, ...options };\r\n        this.update();\r\n    };\r\n\r\n    /**\r\n     * 停止识别\r\n     */\r\n    stop() {\r\n        this._isStopped = true;\r\n    }\r\n\r\n    /**\r\n     * 删除识别器\r\n     * @param {String} 识别器name\r\n     */\r\n    remove(recognizerName: string): void {\r\n        for (let [index, recognizer] of this.recognizers.entries()) {\r\n            if (recognizerName === recognizer.options.name) {\r\n                this.recognizers.splice(index, 1);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 监听input变化\r\n     * @param {Event}\r\n     */\r\n    inputListener(event: Event): void {\r\n        if (this.options.isPreventDefault) {\r\n            event.preventDefault();\r\n        }\r\n\r\n        if (!event.cancelable) {\r\n            this.eventEmitter.emit('error', { code: 0, message: '页面滚动的时候, 请暂时不要操作元素!' });\r\n        }\r\n\r\n        // 管理历史input\r\n        let inputs = this.inputManage.load(event);\r\n        // 跳过无效输入\r\n        // 如: 当是鼠标事件的时候, mouseup阶段的input为undefined\r\n        if (undefined !== inputs) {\r\n            // inputs !== undefined 说明input不为undefined,\r\n            // 因为inputManage中如果input为undefined的时候, inputs才为undefined\r\n            const computed = compute(<any>inputs);\r\n            // input事件\r\n            this.emit('input', computed);\r\n            if (computed.isFirst) {\r\n                // cache.reset();\r\n                this._isStopped = false;\r\n                this.emit('inputstart', computed);\r\n            } else if (computed.isFinal) {\r\n                if ('cancel' === computed.eventType) {\r\n                    this.emit('inputcancel', computed);\r\n                } else {\r\n                    this.emit('inputend', computed);\r\n                }\r\n            } else {\r\n                // prevInput和input一定不为空\r\n                if (inputs.prevInput!.pointLength > inputs.input!.pointLength) {\r\n                    this.emit('inputreduce', computed);\r\n                } else if (inputs.prevInput!.pointLength < inputs.input!.pointLength) {\r\n                    this.emit('inputadd', computed);\r\n                } else {\r\n                    this.emit('inputmove', computed);\r\n                }\r\n            };\r\n\r\n\r\n            for (let recognizer of this.recognizers) {\r\n                if (recognizer.disabled) continue;\r\n                // 如果遇到停止标记, 立即停止运行后面的识别器\r\n                recognizer.recognize(computed);\r\n                if (this._isStopped) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 注册事件\r\n     * @param {String} 事件名\r\n     * @param {Function} 回调函数\r\n     */\r\n    on(type: string, listener: (event: Computed) => void, options: { [k: string]: boolean } | boolean = false): void {\r\n        this.eventEmitter.on(type, listener);\r\n    };\r\n\r\n    /**\r\n     * 解绑事件\r\n     * @param {String} 事件名 \r\n     * @param {Function} 事件回调\r\n     */\r\n    off(type: string, listener?: (event: Computed) => void): void {\r\n        this.eventEmitter.off(type, listener);\r\n    };\r\n\r\n    /**\r\n     * 触发事件, 同时type会作为payload的一个键值\r\n     * @param {String} 类型名\r\n     * @param {Object} 数据\r\n     */\r\n    emit(type: string, payload: Computed) {\r\n        this.eventEmitter.emit(type, { ...payload, type });\r\n    };\r\n\r\n    /**\r\n     * 解绑所有触摸事件\r\n     */\r\n    unbind(): void { };\r\n\r\n    /**\r\n     * 销毁\r\n     */\r\n    destroy() {\r\n        cache.reset();\r\n        // 解绑事件\r\n        this.unbind();\r\n        this.eventEmitter.destroy();\r\n    };\r\n};","/**\r\n * 管理实例和元素的映射关系\r\n * 一个元素只能对应一个实例\r\n */\r\nexport default class <T extends { new(...arys: any): any }> {\r\n    // 存储映射关系\r\n    stock: { el: HTMLElement, instance: InstanceType<T> }[] = [];\r\n    ClassObject: T;\r\n\r\n    constructor(ClassObject: T) {\r\n        this.stock = [];\r\n        this.ClassObject = ClassObject;\r\n    };\r\n\r\n    /**\r\n    * 获取元素在stock中的索引\r\n    * @param {Element} 元素 \r\n    * @returns {Number} 元素索引 \r\n    */\r\n    getIndexByEl(el: HTMLElement): number {\r\n        for (let i = 0, len = this.stock.length; i < len; i++) {\r\n            if (el === this.stock[i].el) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    /**\r\n     * 获取实例\r\n     * @param {Number} 索引\r\n     * @return {InstanceType<T>} 实例 \r\n     */\r\n    getInstanceByIndex(index: number): InstanceType<T> {\r\n        return this.stock[index]!.instance;\r\n    };\r\n\r\n    /**\r\n     * 删除指定实例\r\n     * @param {Number} 索引\r\n     */\r\n    removeInstanceByIndex(index: number): void {\r\n        this.stock.splice(index, 1);\r\n    };\r\n\r\n    /**\r\n     * 获取实例, 如果没有新建\r\n     * @param {Element} 目标元素\r\n     * @param {InstanceType<T>}  InstanceType<T>实例\r\n     */\r\n    getOrCreateInstanceByEl(el: HTMLElement): InstanceType<T> {\r\n        const manageIndex = this.getIndexByEl(el);\r\n        // 防止同一个元素上同一个指令实例化多个InstanceType<T>\r\n        if (-1 === manageIndex) {\r\n            // 新建实例\r\n            const instance = new this.ClassObject(el);\r\n            this.stock.push({el, instance});\r\n            return instance;\r\n        } else {\r\n            return this.getInstanceByIndex(manageIndex);\r\n        }\r\n    };\r\n};","// 注意: 由于vue指令没办法对指令进行优先级设置, 所以指令版本并不能实现AnyTouch所有的功能,\r\n// 比如新建手势. 所以指令版只支持tap/doubletap/pan/swipe/rotate/pinch等默认手势\r\nimport { Computed } from '../interface';\r\nimport { VueConstructor } from 'vue/types/vue';\r\nimport { DirectiveBinding } from 'vue/types/options';\r\nimport InstanceManage from './InstanceManage';\r\nimport { AnyTouch } from '../AnyTouch';\r\n\r\n// 管理实例和元素的映射关系\r\nconst iManage = new InstanceManage(AnyTouch);\r\n// 导出指令\r\nconst plugin = {\r\n    install(Vue: VueConstructor) {\r\n        const _bindEvent = (el: HTMLElement, binding: DirectiveBinding) => {\r\n            let instance = iManage.getOrCreateInstanceByEl(el);\r\n            // 导入AnyTouch实例\r\n            if (undefined !== binding.value) {\r\n                binding.value(instance);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * 解除绑定事件\r\n         * @param {Element} 关联元素 \r\n         */\r\n        const _unbindEvent = (el: HTMLElement) => {\r\n            const index = iManage.getIndexByEl(el);\r\n            // 防止一个元素上的多个手势指令会重复触发删除\r\n            if (-1 !== index && undefined !== iManage.getInstanceByIndex(index)) {\r\n                iManage.getInstanceByIndex(index).destroy();\r\n                iManage.removeInstanceByIndex(index);\r\n            }\r\n        };\r\n\r\n        Vue.directive('touch', {\r\n            inserted(el, binding) {\r\n                _bindEvent(el, binding);\r\n            },\r\n\r\n            update(el, binding) {\r\n                _bindEvent(el, binding);\r\n            },\r\n\r\n            unbind(el) {\r\n                _unbindEvent(el);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n// if('test' !== process.env.NODE_ENV){\r\n    \r\n// }\r\n// 自动加载插件\r\n// if (typeof <any>window !== 'undefined' && (<any>window).Vue) {\r\n//     (<any>window).Vue.use(plugin);\r\n// };\r\n\r\nexport default plugin;\r\n","import { AnyTouch } from './AnyTouch';\r\nimport VueDirective from './vueDirective';\r\nexport default class extends AnyTouch {\r\n    // vue指令版\r\n    static vTouch = VueDirective;\r\n}"],"names":["__values","__read","__spread","Touch","Mouse","default_1","InputFactory","tslib_1.__values","clearTimeout","tslib_1.__extends","Base","InputManage","AnyEvent","Rotate","Pinch","Pan","Swipe","Tap","Press","InstanceManage","VueDirective"],"mappings":"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"}